\documentclass{article}
\usepackage[UTF8]{ctex}

\usepackage{geometry}
\geometry{a4paper,scale=0.8}

\usepackage{fontspec}
\setmainfont{Consolas}

\usepackage{listings}
\lstset{language=c++,numbers=left,frame=single,tabsize=4,breaklines=true,basicstyle=\small}

\begin{document}

\title{acm-icpc template}
\author{HZ}
\maketitle

\tableofcontents

\section{基本内容}

\subsection{代码开头}
\begin{lstlisting}
#include <bits/stdc++.h>
#define forto(i,a,b) for(int i=(a);i<=(b);i++)
#define fordown(i,a,b) for(int i=(a);i>=(b);i--)
#define MIN(a,b) ((a)<=(b)?(a):(b))
#define MAX(a,b) ((a)>=(b)?(a):(b))
#define cmin(a,b) ((a)<=(b)?(a):(a)=(b))
#define cmax(a,b) ((a)>=(b)?(a):(a)=(b))
#define ABS(x) ((x)>=0?(x):-(x))
#define IL inline
#define OP operator
typedef long long LL;
typedef double D;
\end{lstlisting}

\subsection{快速输入输出}
\begin{lstlisting}
// Fast getchar
char B[1<<20],*S=B,*T=B;
#define getchar() (S==T&&(T=(S=B)+fread(B,1,1<<20,stdin),S==T)?0:*S++)

// Fast putchar
char U[1<<20],*O=U,*W=U+(1<<20);
#define putchar(c) (O==W?fwrite(U,1,1<<20,stdout),O=U,1:1,*O++=(c))
#define clr_buf() (fwrite(U,1,O-U,stdout),O=U)
// remember to clr_buf() before return 0 in the end

// Fast Input
#define isd(c) ((c)>='0'&&(c)<='9')
IL char read(int &x){
	static char c; static bool f;
	x=0; c=getchar(); f=false;
	while (!isd(c) && c!='-') c=getchar();
	if (c=='-') { f=true; c=getchar(); }
	while (isd(c)) { x=x*10+c-'0'; c=getchar(); }
	if (f) x=-x;
	return c;
}

IL char read(D &x){
	static char c; static bool f;
	x=0; c=getchar(); f=false;
	while (!isd(c) && c!='-' && c!='.') c=getchar();
	if (c=='-') { f=true; c=getchar(); }
	while (isd(c)) { x=x*10+c-'0'; c=getchar(); }
	if (c=='.') {
		static D t; t=1; c=getchar();
		while (isd(c)) { x+=(t/=10)*(c-'0'); c=getchar(); }
	}
	if (f) x=-x;
	return c;
}

IL void read(char s[]){
	s++; *s=getchar();
	while (*s==' '||*s=='\n') *s=getchar();
	while (*s!=' '&&*s!='\n') *++s=getchar();
	*s=0;
}

// Fast Output
IL void write(int x){
	if (x<0) { putchar('-'); x=-x; }
	if (!x) { putchar('0'); return; }
	static char c[20]; static int top; top=0;
	while (x) { c[++top]='0'+x%10; x/=10; }
	while (top) putchar(c[top--]);
}

IL void write(D x){
	static LL t; t=int(x*1e6+(x>=0?0.5:-0.5));
	if (t<0) { putchar('-'); t=-t; }
	static char c[20]; static int top; top=0;
	while (t) { c[++top]='0'+t%10; t/=10; }
	while (top<=6) c[++top]='0';
	while (top>6) putchar(c[top--]);
	putchar('.');
	while (top) putchar(c[top--]);
}

IL void write(char s[]){
	s++; while (*s) putchar(*s++);
}
\end{lstlisting}

\subsection{哈希表}
\begin{lstlisting}
const int H=(1<<20)-1;
struct hash_map{
	int la[1<<20],top;
	struct E { LL key; int da,ne; } e[int(1e6)];
	IL void clear(){
		memset(la,0,sizeof(la)); top=0;
	}
	IL bool count(LL k){
		static int i; i=la[k&H];
		while (i&&e[i].key!=k) i=e[i].ne;
		return i;
	}
	IL int& OP[] (LL k){
		static int h,i; i=la[h=k&H];
		while (i&&e[i].key!=k) i=e[i].ne;
		if (!i){ e[i=++top]=(E){k,0,la[h]}; la[h]=top; }
		return e[i].da;
	}
};
\end{lstlisting}

\section{数学基础}

\subsection{快速幂}
\begin{lstlisting}
IL int pow(int a, LL b, int n){  //a^b mod n
	static int p; p=1;
	for(;b;b>>=1,a=LL(a)*a%n)
		if (b&1) p=LL(p)*a%n;
    return p;
}
\end{lstlisting}

\subsection{同余相关}
\begin{lstlisting}
IL LL gcd(LL a, LL b){
	static LL c;
	while (b) { c=a%b; a=b; b=c; }
	return a;
}

IL LL lcm(LL a, LL b) { return a/gcd(a,b)*b; }

void gcd(LL a, LL b, LL &d, LL &x, LL &y){
	if (!b){ d=a; x=1; y=0; return; }
	gcd(b,a%b,d,y,x); y-=x*(a/b);
}

IL void sim(LL &a, LL n){ a%=n; if (a<0) a+=n; }

IL LL solve(LL a, LL b, LL n){  // a*x==b (mod n)
	sim(a,n); sim(b,n);  // optional
	static LL d,x,y; gcd(a,n,d,x,y);
	if (b%d) return -1;
	b/=d; n/=d;
	if (x<0) x+=n;
	return b*x%n;
}

// x==a1 (mod n1); x==a2 (mod n2);
void merge(LL a1, LL n1, LL a2, LL n2, LL &x, LL &n){
	n=n1/gcd(n1,n2)*n2;
	LL k=solve(n1,a2-a1,n2);	
	if (k==-1){ x=-1; return; }
	sim(x=n1*k+a1,n);
}

// getinv , gcd(a,n) must be 1
IL LL getinv(LL a, LL n){
	static LL d,x,y;
	gcd(a,n,d,x,y);
	// if (d!=1) return -1;
	return x<0?x+n:x;
}
\end{lstlisting}

\subsection{线性筛法}
\begin{lstlisting}
const int N=100000;
bool b[N+10];
int a[N+10],cnt,mx[N+10],phi[N+10],mu[N+10];

void getprime(){
	forto(i,2,N) b[i]=true;
	mu[1]=1;
	forto(i,2,N){
		if (b[i]){
			a[++cnt]=i;
			mx[i]=cnt; phi[i]=i-1; mu[i]=-1;
		}
		for(int j=1; j<=mx[i]&&i*a[j]<=N; j++){
			int k=i*a[j];
			b[k]=false; mx[k]=j;
			phi[k]= j==mx[i] ? phi[i]*a[j] : phi[i]*(a[j]-1);
			mu[k]= j==mx[i] ? 0 : -mu[i];
		}
	}
}
\end{lstlisting}

\subsection{离散对数}
\begin{lstlisting}
// BSGS , a^x==b (mod n) , n is a prime
LL bsgs(LL a, LL b, LL n){
	LL m=(int)sqrt(n+0.5);
	LL p=pow(a,m,n); LL v=getinv(p,n);
	static hash_map x;
	x.clear();
	LL e=1; x[e]=0;
	for(LL i=1;i<=m;i++){
		e=e*a%n;
		if (!x.count(e)) x[e]=i;
	}
	for(LL i=0;i<n;i+=m){
		if (x.count(b)) return i+x[b];
		b=b*v%n;
	}
	return -1;
}
\end{lstlisting}

\subsection{Lucas}
\begin{lstlisting}
void init_Lucas(){
	fac[0]=1; forto(i,1,MOD-1) fac[i]=fac[i-1]*i%MOD;
	inv[1]=1; forto(i,2,MOD-1) inv[i]=(MOD-MOD/i)*inv[MOD%i]%MOD;
	inv[0]=1; forto(i,1,MOD-1) inv[i]=inv[i-1]*inv[i]%MOD;
}

IL LL C(int n, int m){
	LL ans=1;
	while (n||m){
		int a=n%MOD, b=m%MOD;
		n/=MOD; m/=MOD;
		if (a<b) return 0;
		ans= ans *fac[a]%MOD *inv[b]%MOD *inv[a-b]%MOD;
	}
	return ans;
}
\end{lstlisting}

\subsection{分数类和高斯消元}
\begin{lstlisting}
#include<bits/stdc++.h>
#define forto(i,a,b) for(int i=(a);i<=(b);i++)
#define ABS(x) ((x)>=0?(x):-(x))  
#define IL inline
#define OP operator
#define RR const R &
typedef long long LL;

IL LL gcd(LL a, LL b){  
	while (b) { LL c=a%b; a=b; b=c; }
	return a;
}

struct R{  
	LL x,y;

	IL void sim(){  
		if (y<0) { x=-x; y=-y; }
		LL d=gcd(ABS(x),y);
		x/=d; y/=d;
	}

	IL void pri() const { 
		printf("%lld",x);
		if (y>1) printf("/%lld",y);
	}
};

IL R OP+ (RR a, RR b){
	R c=(R){a.x*b.y + b.x*a.y, a.y*b.y};
	c.sim(); return c;
}

IL R OP- (RR a, RR b){
	R c=(R){a.x*b.y - b.x*a.y, a.y*b.y};
	c.sim(); return c;
}

IL R OP* (RR a, RR b){
	R c=(R){a.x*b.x, a.y*b.y};
	c.sim(); return c;
}

IL R OP/ (RR a, RR b){
	R c=(R){a.x*b.y, a.y*b.x};
	c.sim(); return c;
}

const int N=1000;
int n,m;
R a[N][N];

void solve(){
	scanf("%d%d",&n,&m);
	
	forto(i,1,n) forto(j,1,m){
		scanf("%lld",&a[i][j].x);
		a[i][j].y=1;
	}
	 
	int i=1, j=1;
	while (i<=n && j<=m){
		int k=i;
		while (k<=n && a[k][j].x==0) k++;
		if (k>n) { j++; continue; }
		if (k!=i) forto(t,j,m) std::swap(a[i][t],a[k][t]);
		
		forto(p,j+1,m) a[i][p]=a[i][p]/a[i][j];
		a[i][j]=(R){1,1};
		
		forto(t,1,n) if (t!=i && a[t][j].x){
			forto(p,j+1,m) a[t][p]=a[t][p]-a[i][p]*a[t][j];
			a[t][j]=(R){0,1};
		}
		i++; j++;
	}
	
	putchar('\n');
	forto(i,1,n) forto(j,1,m){
		a[i][j].pri();
		putchar(j==m?'\n':' ');
	}
	putchar('\n');
}

int main(){
	while (true) solve();
	return 0;
}
\end{lstlisting}

\subsection{FFT}
\begin{lstlisting}
#include<cstdlib>
#include<cstdio>
#include<cmath>

#define forto(i,a,b) for(int i=(a);i<=(b);i++)
#define fordown(i,a,b) for(int i=(a);i>=(b);i--)

const double pi=acos(-1);
const int N=300000;

struct P{ double x,y; };
P operator+ (const P &a, const P &b) { return (P){a.x+b.x, a.y+b.y}; }
P operator- (const P &a, const P &b) { return (P){a.x-b.x, a.y-b.y}; }
P operator* (const P &a, const P &b) { return (P){a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x}; }

P w1[N],w2[N];
int rev[N];

void initfft(int n){
	int k=0, nn=n>>1;
	while (nn){ nn>>=1; k++; }
	double t=pi*2/n;
	forto(i,0,n-1){
		rev[i]=(rev[i>>1]>>1)+((i&1)<<(k-1));
		w1[i]=w2[(n-i)%n]=(P){cos(t*i),sin(t*i)};
	}
}

void fft(int n, P a[], P w[]){
	forto(i,0,n-1) if (i<rev[i]) { P t=a[i]; a[i]=a[rev[i]]; a[rev[i]]=t; }
	for(int k=1;k<n;k<<=1)
	for(int i=0;i<n;i+=k<<1)
	for(int j=0;j<k;j++){
		P t1=a[i+j], t2=a[i+j+k]*w[n/(k<<1)*j];
		a[i+j]=t1+t2; a[i+j+k]=t1-t2;
	}
}

int s1[N],s2[N];
P a1[N],a2[N];

int main(){
	int n1,n2; scanf("%d%d",&n1,&n2);
	forto(i,0,n1) scanf("%d",&s1[i]);
	forto(i,0,n2) scanf("%d",&s2[i]);
	forto(i,0,n1) a1[i]=(P){double(s1[i]),0};
	forto(i,0,n2) a2[i]=(P){double(s2[i]),0};
	int n=1;
	while (n<=n1+n2) n<<=1;
	initfft(n);
	fft(n,a1,w1);
	fft(n,a2,w1);
	forto(i,0,n-1) a1[i]=a1[i]*a2[i];
	fft(n,a1,w2);
	forto(i,0,n1+n2) printf("%d ",int(round(a1[i].x/n)));
	return 0;
}
\end{lstlisting}


\section{字符串}

\subsection{KMP}
\begin{lstlisting}
// next[1]=0; kmp(s+1, next+1, s, next);
void kmp(char s1[], int next1[], char s2[], int next2[]){
	for(int i=1,j=0; s1[i]; i++){
        while (j && s1[i]!=s2[j+1]) j=next2[j];
        if (s1[i]==s2[j+1]) j++;
        next1[i]=j;
    }
}
\end{lstlisting}

\subsection{扩展KMP}
\begin{lstlisting}
// extkmp(s+1, ext+1, s, ext);
void extkmp(char s1[], int ext1[], char s2[], int ext2[]){
	int len1=strlen(s1+1), len2=strlen(s2+1);
	int k=1, j=0;
	while (s1[j+1]==s2[j+1]&&j<len1) j++;
	ext1[1]=j;
	for (int i=2;i<=len1;i++){
		int len=ext2[i-k+1];
		if (i+len-1<j) ext1[i]=len;
		else {
			len=j-i+1;
			if (len<0) len=0;
			while (s1[i+len]==s2[len+1]&& len<len2) len++;
			ext1[i]=len;
			k=i; j=i+len-1;
		}
	}
}
\end{lstlisting}

\subsection{后缀数组}
\begin{lstlisting}
int n,sa[N],rk[N<<1],c[N],x[N],h[N];
void suffix_array(int s[]){
	forto(i,1,n){ sa[i]=i; rk[i]=s[i]; }
	for(int m=300,k=0; k<n; k?k<<=1:k++){
		forto(i,1,m) c[i]=0;
		forto(i,1,n) c[rk[i]]++;
		forto(i,2,m) c[i]+=c[i-1];
		int p=0;
		forto(i,n-k+1,n) x[++p]=i;
		forto(i,1,n) if (sa[i]>k) x[++p]=sa[i]-k;
		fordown(i,n,1) sa[c[rk[x[i]]]--]=x[i];
		m=1; x[sa[1]]=1;
		forto(i,2,n) x[sa[i]]= rk[sa[i]]==rk[sa[i-1]] && rk[sa[i]+k]==rk[sa[i-1]+k] ?m:++m;
		forto(i,1,n) rk[i]=x[i];
		if (m==n) break;
	}
	forto(i,1,n) if (rk[i]!=n){
		int j=sa[rk[i]+1];
		h[i]=h[i-1]?h[i-1]-1:0;
		while (s[i+h[i]]==s[j+h[i]]) h[i]++;
	}
}
\end{lstlisting}

\subsection{manacher}
\begin{lstlisting}
char str[N],s[N<<1];
int f[N<<1];

void manacher(){
	int n=0;
	for(int i=0;str[i];i++){
		s[++n]='#';
		s[++n]=str[i];
	}
	s[++n]='#';

	int mx=1,mr=1;
	forto(i,2,n){
		int t=0;
		if (i<mr) t=MIN(f[2*mx-i],mr-i);
		while (i-t-1 && s[i-t-1]==s[i+t+1]) t++;
		f[i]=t;
		if (i+t>mr){ mx=i; mr=i+t; }
	}
}
\end{lstlisting}

\section{图论}

\subsection{强连通分量}
\begin{lstlisting}
int dfn[N],low[N],time;
int scc[N],cnt;
int sta[N],top;
int size[N];

void dfs(int x){
    dfn[x]=low[x]=++time;
    sta[++top]=x;
    forE(i,x){
        int y=e[i].to;
        if (!scc[y]){
            if (!dfn[y]) dfs(y);
            if (low[y]<low[x]) low[x]=low[y];
        }
    }
    if (dfn[x]==low[x]){
        cnt++;
        while (!scc[x]){
            scc[sta[top--]]=cnt;
            size[cnt]++;
        }
    }
}

forto(i,1,n) if (!dfn[i]) dfs(i);
\end{lstlisting}

\subsection{割顶和桥}
\begin{lstlisting}
int dfn[N],low[N],cnt;
int sta[N],top;
int scc[N],scc_cnt;

void dfs(int x, int fa){
	dfn[x]=low[x]=++cnt; sta[++top]=x;
	for(int i=la[x];i;i=e[i].ne){
		int y=e[i].to;
		if (y!=fa){
			if (low[y]==0){
				dfs(y,x);
				low[x]=MIN(low[x],low[y]);
			} else low[x]=MIN(low[x],dfn[y]);
		}
	}
	if (dfn[x]==low[x]){
		scc_cnt++;
		while (sta[top]!=x) scc[sta[top--]]=scc_cnt;
		scc[sta[top--]]=scc_cnt;
	}	
}
\end{lstlisting}

\subsection{网络流}
\begin{lstlisting}
int n,m,la[N],top,q[N],cur[N],dis[N];
struct E{int to,cap,next;} e[M*2];

void add(int a, int b, int c){
	e[++top]=(E){b,c,la[a]}; la[a]=top;
	e[++top]=(E){a,0,la[b]}; la[b]=top;
}
	// remember to set top=1

bool bfs(){
	forto(i,1,n) dis[i]=inf; dis[1]=0;
	int l=1, r=1; q[1]=1;
	while (l<=r){
		int t=q[l++];
		for(int i=la[t];i;i=e[i].next)
		if (e[i].cap && dis[e[i].to]==inf)
			dis[ q[++r]=e[i].to ]=dis[t]+1;
	}
	return dis[n]!=inf;
}

int dinic(int x, int a){
	if (x==n||a==0) return a;
	int flow=0;
	for(int &i=cur[x];i;i=e[i].next)
	if (dis[e[i].to]==dis[x]+1 && e[i].cap){
		int t=dinic(e[i].to,MIN(a,e[i].cap));
		flow+=t; a-=t;
		e[i].cap-=t; e[i^1].cap+=t;
		if (a==0) return flow;
	}
	return flow;
}

int maxflow(){
	int flow=0;
	while (bfs()){
		forto(i,1,n) cur[i]=la[i];
		flow+=dinic(1,inf);
	}
	return flow;
}
\end{lstlisting}

\subsection{hzwer的网络流}
\begin{lstlisting}
// dinic

bool bfs()
{
	int head=0,tail=1;
	for(int i=0;i<=T;i++)h[i]=-1;
	q[0]=0;h[0]=0;
	while(head!=tail)
	{
		int now=q[head];head++;
		for(int i=last[now];i;i=e[i].next)
			if(e[i].v&&h[e[i].to]==-1)
			{
				h[e[i].to]=h[now]+1;
				q[tail++]=e[i].to;
			}
	}
	return h[T]!=-1;
}

int dfs(int x,int f)
{
	if(x==T)return f;
	int w,used=0;
	for(int i=cur[x];i;i=e[i].next)
		if(h[e[i].to]==h[x]+1)
		{
			w=f-used;
			w=dfs(e[i].to,min(w,e[i].v));
			e[i].v-=w;e[i^1].v+=w;
			if(e[i].v)cur[x]=i;
			used+=w;if(used==f)return f;
		}
	if(!used)h[x]=-1;
	return used;
}

void dinic()
{
	while(bfs())
	{
		for(int i=0;i<=T;i++)
			cur[i]=last[i];
		ans+=dfs(0,inf);
	}
} 

// spfa

bool spfa()
{
	for(int i=0;i<=T;i++)dis[i]=inf;
	int head=0,tail=1;
	dis[0]=0;q[0]=0;inq[0]=1;
	while(head!=tail)
	{
		int now=q[head++];if(head==1601)head=0;
		for(int i=last[now];i;i=e[i].next)
			if(e[i].v&&e[i].c+dis[now]<dis[e[i].to])
			{
				dis[e[i].to]=e[i].c+dis[now];
				from[e[i].to]=i;
				if(!inq[e[i].to])
				{
					inq[e[i].to]=1;
					if(dis[e[i].to]<dis[q[head]])
					{
						head--;if(head==-1)head=1600;
						q[head]=e[i].to;
					}
					else
					{
						q[tail++]=e[i].to;
						if(tail==1601)tail=0;
					}
				}
			}
		inq[now]=0;
	}
	if(dis[T]==inf)return 0;
	return 1;
}

void mcf()
{
	int x=inf;
	for(int i=from[T];i;i=from[e[i].from])
		x=min(e[i].v,x);
	for(int i=from[T];i;i=from[e[i].from])
	{
		ans+=x*e[i].c;
		e[i].v-=x;e[i^1].v+=x;
	}
}

// zkw

bool spfa()
{
    memset(mark,0,sizeof(mark));
    for(int i=0;i<=T;i++)d[i]=-1;
    int head=0,tail=1;
    q[0]=T;mark[T]=1;d[T]=0;
    while(head!=tail)
    {
		int now=q[head];head++;if(head==605)head=0;
		for(int i=last[now];i;i=e[i].next)
			if(e[i^1].v&&d[now]+e[i^1].c>d[e[i].to])
			{
				d[e[i].to]=d[now]+e[i^1].c;
				if(!mark[e[i].to])
				{
					mark[e[i].to]=1;
					q[tail++]=e[i].to;
					if(tail==605)tail=0;
				}
			}
		mark[now]=0;
    }
    return d[0]!=-1;
}

int dfs(int x,int f)
{
    mark[x]=1;
    if(x==T)return f;
    int w,used=0;
    for(int i=last[x];i;i=e[i].next)
		if(d[e[i].to]==d[x]-e[i].c&&e[i].v&&!mark[e[i].to])
		{
			w=f-used;
			w=dfs(e[i].to,min(w,e[i].v));
			ans+=w*e[i].c;
			e[i].v-=w;e[i^1].v+=w;
			used+=w;if(used==f)return f;
		}
    return used;
}

void zkw()
{
    while(spfa())
    {
		mark[T]=1;
		while(mark[T])
		{
			memset(mark,0,sizeof(mark));
			dfs(0,inf);
		}
    }
}
\end{lstlisting}

\end{document}