\documentclass{article}
\usepackage[UTF8]{ctex}

\usepackage{geometry}
\geometry{a4paper,scale=0.8}

\usepackage{fontspec}
\setmainfont{Consolas}

\usepackage{listings}
\lstset{language=c++,numbers=left,frame=single,tabsize=4,breaklines=true,basicstyle=\small}

\begin{document}

\title{HZ的acm模板}
\author{HZ}
\maketitle
\tableofcontents

\section{基本内容}

\subsection{代码开头}
\begin{lstlisting}
#include <bits/stdc++.h>
#define forto(i,a,b) for(int i=(a);i<=(b);i++)
#define fordown(i,a,b) for(int i=(a);i>=(b);i--)
#define MIN(a,b) ((a)<=(b)?(a):(b))
#define MAX(a,b) ((a)>=(b)?(a):(b))
#define cmin(a,b) ((a)<=(b)?(a):(a)=(b))
#define cmax(a,b) ((a)>=(b)?(a):(a)=(b))
#define ABS(x) ((x)>=0?(x):-(x))
#define IL inline
#define OP operator
typedef long long LL;
typedef double D;
const D pi=acos(-1);
\end{lstlisting}

\subsection{快速输入输出}
\begin{lstlisting}
// Fast getchar
char B[1<<20],*S=B,*T=B;
#define getchar() (S==T&&(T=(S=B)+fread(B,1,1<<20,stdin),S==T)?0:*S++)

// Fast putchar
char U[1<<20],*O=U,*W=U+(1<<20);
#define putchar(c) (O==W?fwrite(U,1,1<<20,stdout),O=U,1:1,*O++=(c))
#define clr_buf() (fwrite(U,1,O-U,stdout),O=U)
// remember to clr_buf() before return 0 in the end

// Fast Input
#define isd(c) ((c)>='0'&&(c)<='9')
IL char read(int &x){
	static char c; static bool f;
	x=0; c=getchar(); f=false;
	while (!isd(c) && c!='-') c=getchar();
	if (c=='-') { f=true; c=getchar(); }
	while (isd(c)) { x=x*10+c-'0'; c=getchar(); }
	if (f) x=-x;
	return c;
}

IL char read(D &x){
	static char c; static bool f;
	x=0; c=getchar(); f=false;
	while (!isd(c) && c!='-' && c!='.') c=getchar();
	if (c=='-') { f=true; c=getchar(); }
	while (isd(c)) { x=x*10+c-'0'; c=getchar(); }
	if (c=='.') {
		static D t; t=1; c=getchar();
		while (isd(c)) { x+=(t/=10)*(c-'0'); c=getchar(); }
	}
	if (f) x=-x;
	return c;
}

IL void read(char s[]){
	s++; *s=getchar();
	while (*s==' '||*s=='\n') *s=getchar();
	while (*s!=' '&&*s!='\n') *++s=getchar();
	*s=0;
}

// Fast Output
IL void write(int x){
	if (x<0) { putchar('-'); x=-x; }
	if (!x) { putchar('0'); return; }
	static char c[20]; static int top; top=0;
	while (x) { c[++top]='0'+x%10; x/=10; }
	while (top) putchar(c[top--]);
}

IL void write(D x){
	static LL t; t=int(x*1e6+(x>=0?0.5:-0.5));
	if (t<0) { putchar('-'); t=-t; }
	static char c[20]; static int top; top=0;
	while (t) { c[++top]='0'+t%10; t/=10; }
	while (top<=6) c[++top]='0';
	while (top>6) putchar(c[top--]);
	putchar('.');
	while (top) putchar(c[top--]);
}

IL void write(char s[]){
	s++; while (*s) putchar(*s++);
}
\end{lstlisting}


\section{数学基础}

\subsection{快速幂}
\begin{lstlisting}
IL int pow(int a, LL b, int n){  //a^b mod n
	static int p; p=1;
	for(;b;b>>=1,a=LL(a)*a%n)
		if (b&1) p=LL(p)*a%n;
    return p;
}
\end{lstlisting}

\subsection{同余相关}
\begin{lstlisting}
IL LL gcd(LL a, LL b){
	static LL c;
	while (b) { c=a%b; a=b; b=c; }
	return a;
}

IL LL lcm(LL a, LL b) { return a/gcd(a,b)*b; }

void gcd(LL a, LL b, LL &d, LL &x, LL &y){
	if (!b){ d=a; x=1; y=0; return; }
	gcd(b,a%b,d,y,x); y-=x*(a/b);
}

IL void sim(LL &a, LL n){ a%=n; if (a<0) a+=n; }

IL LL solve(LL a, LL b, LL n){  // a*x==b (mod n)
	sim(a,n); sim(b,n);  // optional
	static LL d,x,y;
	gcd(a,n,d,x,y);
	if (b%d) return -1;
	b/=d; n/=d;
	if (x<0) x+=n;
	return b*x%n;
}

// x==a1 (mod n1); x==a2 (mod n2);
void merge(LL a1, LL n1, LL a2, LL n2, LL &x, LL &n){
	n=n1/gcd(n1,n2)*n2;
	LL k=solve(n1,a2-a1,n2);	
	if (k==-1){ x=-1; return; }
	sim(x=n1*k+a1,n);
}

// getinv , gcd(a,n) must be 1
IL LL getinv(LL a, LL n){
	static LL d,x,y;
	gcd(a,n,d,x,y);
	// if (d!=1) return -1;
	return x<0?x+n:x;
}
\end{lstlisting}

\subsection{线性筛法}
\begin{lstlisting}
const int N=100000;
bool b[N+10];
int a[N+10],cnt,mx[N+10],phi[N+10],mu[N+10];

void getprime(){
	forto(i,2,N) b[i]=true;
	mu[1]=1;
	forto(i,2,N){
		if (b[i]){
			a[++cnt]=i;
			mx[i]=cnt; phi[i]=i-1; mu[i]=-1;
		}
		for(int j=1; j<=mx[i]&&i*a[j]<=N; j++){
			int k=i*a[j];
			b[k]=false; mx[k]=j;
			phi[k]= j==mx[i] ? phi[i]*a[j] : phi[i]*(a[j]-1);
			mu[k]= j==mx[i] ? 0 : -mu[i];
		}
	}
}
\end{lstlisting}

\subsection{离散对数}
\begin{lstlisting}
// BSGS , a^x==b (mod n) , n is a prime
LL bsgs(LL a, LL b, LL n){
	LL m=(int)sqrt(n+0.5);
	LL p=pow(a,m,n); LL v=getinv(p,n);
	static hash_map x;
	x.clear();
	LL e=1; x[e]=0;
	for(LL i=1;i<=m;i++){
		e=e*a%n;
		if (!x.count(e)) x[e]=i;
	}
	for(LL i=0;i<n;i+=m){
		if (x.count(b)) return i+x[b];
		b=b*v%n;
	}
	return -1;
}
\end{lstlisting}

\subsection{hzwer的bsgs}
\begin{lstlisting}
//BSGS
//y^x==z (mod p) ->x=?
scanf("%d%d%d",&y,&z,&p),y%=p,z%=p;j=z;
if(y==0){puts("Cannot find x");continue;}
for(k=s=1;k*k<=p;k++);
std::map<int,int>hash;flag=0;
for(int i=0;i<k;i++,s=1LL*s*y%p,j=1LL*j*y%p)hash[j]=i;
for(int i=1,j=s;i<=k&&!flag;i++,j=1LL*j*s%p)
if(hash.count(j))ans=i*k-hash[j],flag=1;
if(flag==0)puts("Cannot find x");
else printf("%d\n",ans);

//exBSGS
int bsgs(int a,ll b,int p){
    if(a%=p,b%=p,b==1)return 0;
    ll t=1;int f,g,delta=0,m=sqrt(p)+1,i;
    for(g=gcd(a,p);g!=1;g=gcd(a,p)){
        if(b%g)return -1;
        b/=g,p/=g,t=t*(a/g)%p,delta++;
        if(b==t)return delta;
    }
    std::map<int,int>hash;
    for(i=0;i<m;i++,b=b*a%p)hash[b]=i;
    for(i=1,f=power(a,m);i<=m+1;i++)
    if(t=t*f%p,hash.count(t))return i*m-hash[t]+delta;
    return -1;
}
\end{lstlisting}

\subsection{Lucas}
\begin{lstlisting}
void init_Lucas(){
	fac[0]=1; forto(i,1,MOD-1) fac[i]=fac[i-1]*i%MOD;
	inv[1]=1; forto(i,2,MOD-1) inv[i]=(MOD-MOD/i)*inv[MOD%i]%MOD;
	inv[0]=1; forto(i,1,MOD-1) inv[i]=inv[i-1]*inv[i]%MOD;
}

IL LL C(int n, int m){
	LL ans=1;
	while (n||m){
		int a=n%MOD, b=m%MOD;
		n/=MOD; m/=MOD;
		if (a<b) return 0;
		ans= ans *fac[a]%MOD *inv[b]%MOD *inv[a-b]%MOD;
	}
	return ans;
}
\end{lstlisting}

\subsection{分数类}
\begin{lstlisting}
#define RR const R &

struct R{
	LL x,y;

	IL void sim(){ 
		if (y<0) { x=-x; y=-y; }
		LL d=gcd(ABS(x),y);
		x/=d; y/=d;
	}

	IL void pri() const {
		printf("%lld",x);
		if (y>1) printf("/%lld",y);
	}
};

IL R OP+ (RR a, RR b){
	R c=(R){a.x*b.y + b.x*a.y, a.y*b.y};
	c.sim(); return c;
}

IL R OP- (RR a, RR b){
	R c=(R){a.x*b.y - b.x*a.y, a.y*b.y};
	c.sim(); return c;
}

IL R OP* (RR a, RR b){
	R c=(R){a.x*b.x, a.y*b.y};
	c.sim(); return c;
}

IL R OP/ (RR a, RR b){
	R c=(R){a.x*b.y, a.y*b.x};
	c.sim(); return c;
}
\end{lstlisting}

\subsection{高斯消元}
\begin{lstlisting}
const int N=1000;
int n,m;
R a[N][N];

void solve(){
	scanf("%d%d",&n,&m);
	
	forto(i,1,n) forto(j,1,m){
		scanf("%lld",&a[i][j].x);
		a[i][j].y=1;
	}
	 
	int i=1, j=1;
	while (i<=n && j<=m){
		int k=i;
		while (k<=n && a[k][j].x==0) k++;
		if (k>n) { j++; continue; }
		if (k!=i) forto(t,j,m) std::swap(a[i][t],a[k][t]);
		
		forto(p,j+1,m) a[i][p]=a[i][p]/a[i][j];
		a[i][j]=(R){1,1};
		
		forto(t,1,n) if (t!=i && a[t][j].x){
			forto(p,j+1,m) a[t][p]=a[t][p]-a[i][p]*a[t][j];
			a[t][j]=(R){0,1};
		}
		i++; j++;
	}
	
	putchar('\n');
	forto(i,1,n) forto(j,1,m){
		a[i][j].pri();
		putchar(j==m?'\n':' ');
	}
	putchar('\n');
}
\end{lstlisting}

\subsection{FFT}
\begin{lstlisting}
struct P{ double x,y; };
P operator+ (const P &a, const P &b) { return (P){a.x+b.x, a.y+b.y}; }
P operator- (const P &a, const P &b) { return (P){a.x-b.x, a.y-b.y}; }
P operator* (const P &a, const P &b) { return (P){a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x}; }

P w1[N],w2[N];
int rev[N];

void initfft(int n){
	int k=0, nn=n>>1;
	while (nn){ nn>>=1; k++; }
	double t=pi*2/n;
	forto(i,0,n-1){
		rev[i]=(rev[i>>1]>>1)+((i&1)<<(k-1));
		w1[i]=w2[(n-i)%n]=(P){cos(t*i),sin(t*i)};
	}
}

void fft(int n, P a[], P w[]){
	forto(i,0,n-1) if (i<rev[i]) { P t=a[i]; a[i]=a[rev[i]]; a[rev[i]]=t; }
	for(int k=1;k<n;k<<=1)
	for(int i=0;i<n;i+=k<<1)
	for(int j=0;j<k;j++){
		P t1=a[i+j], t2=a[i+j+k]*w[n/(k<<1)*j];
		a[i+j]=t1+t2; a[i+j+k]=t1-t2;
	}
}

int s1[N],s2[N];
P a1[N],a2[N];

int main(){
	int n1,n2; scanf("%d%d",&n1,&n2);
	forto(i,0,n1) scanf("%d",&s1[i]);
	forto(i,0,n2) scanf("%d",&s2[i]);
	forto(i,0,n1) a1[i]=(P){double(s1[i]),0};
	forto(i,0,n2) a2[i]=(P){double(s2[i]),0};
	int n=1;
	while (n<=n1+n2) n<<=1;
	initfft(n);
	fft(n,a1,w1);
	fft(n,a2,w1);
	forto(i,0,n-1) a1[i]=a1[i]*a2[i];
	fft(n,a1,w2);
	forto(i,0,n1+n2) printf("%d ",int(round(a1[i].x/n)));
	return 0;
}
\end{lstlisting}


\section{字符串}

\subsection{KMP}
\begin{lstlisting}
// next[1]=0; kmp(s+1, next+1, s, next);
void kmp(char s1[], int next1[], char s2[], int next2[]){
	for(int i=1,j=0; s1[i]; i++){
        while (j && s1[i]!=s2[j+1]) j=next2[j];
        if (s1[i]==s2[j+1]) j++;
        next1[i]=j;
    }
}
\end{lstlisting}

\subsection{扩展KMP}
\begin{lstlisting}
// extkmp(s+1, ext+1, s, ext);
void extkmp(char s1[], int ext1[], char s2[], int ext2[]){
	int len1=strlen(s1+1), len2=strlen(s2+1);
	int k=1, j=0;
	while (s1[j+1]==s2[j+1]&&j<len1) j++;
	ext1[1]=j;
	for (int i=2;i<=len1;i++){
		int len=ext2[i-k+1];
		if (i+len-1<j) ext1[i]=len;
		else {
			len=j-i+1;
			if (len<0) len=0;
			while (s1[i+len]==s2[len+1]&& len<len2) len++;
			ext1[i]=len;
			k=i; j=i+len-1;
		}
	}
}
\end{lstlisting}

\subsection{后缀数组}
\begin{lstlisting}
char s[N];
int n,sa[N],rk[N<<1],c[N],x[N],h[N];

void suffix_array(){
	forto(i,1,n){ sa[i]=i; rk[i]=s[i]; }
	for(int m=300,k=0; k<n; k?k<<=1:k++){
		forto(i,1,m) c[i]=0;
		forto(i,1,n) c[rk[i]]++;
		forto(i,2,m) c[i]+=c[i-1];
		int p=0;
		forto(i,n-k+1,n) x[++p]=i;
		forto(i,1,n) if (sa[i]>k) x[++p]=sa[i]-k;
		fordown(i,n,1) sa[c[rk[x[i]]]--]=x[i];
		m=1; x[sa[1]]=1;
		forto(i,2,n) x[sa[i]]= rk[sa[i]]==rk[sa[i-1]] && rk[sa[i]+k]==rk[sa[i-1]+k] ?m:++m;
		forto(i,1,n) rk[i]=x[i];
		if (m==n) break;
	}
	forto(i,1,n) if (rk[i]!=n){
		int j=sa[rk[i]+1];
		h[i]=h[i-1]?h[i-1]-1:0;
		while (s[i+h[i]]==s[j+h[i]]) h[i]++;
	}
}
\end{lstlisting}

\subsection{manacher}
\begin{lstlisting}
char str[N],s[N<<1];
int f[N<<1];

void manacher(){
	int n=0;
	for(int i=0;str[i];i++){
		s[++n]='#';
		s[++n]=str[i];
	}
	s[++n]='#';

	int mx=1,mr=1;
	forto(i,2,n){
		int t=0;
		if (i<mr) t=MIN(f[2*mx-i],mr-i);
		while (i-t-1 && s[i-t-1]==s[i+t+1]) t++;
		f[i]=t;
		if (i+t>mr){ mx=i; mr=i+t; }
	}
}
\end{lstlisting}

\subsection{回文自动机}
\begin{lstlisting}
const int N=300000+100, alpha=26;
int n,s[N],num[N];
int p,last,next[N][alpha],fail[N],len[N],cnt[N];
void init(){
	s[n=0]=len[p=2]=-1;
	fail[fail[last=1]=2]=2;
}
int getfail(int x){
	while (s[n-len[x]-1]!=s[n]) x=fail[x];
	return x;
}
void add(int c){
	s[++n]=c;
	int cur=getfail(last);
	if (!next[cur][c]){
		len[++p]=len[cur]+2;
		fail[p]=next[getfail(fail[cur])][c];
		if (!fail[p]) fail[p]=1;
		next[cur][c]=p;
	}
	last=next[cur][c];
	cnt[last]++;
}
\end{lstlisting}


\section{图论}

\subsection{树的直径}
\begin{lstlisting}
int bfs(int x){
	q[l=r=1]=x;
	forto(i,1,n) dis[i]=-1;
	dis[x]=0;
	int ans=x;
	while (l<=r){
		x=q[l++];
		for(int i=la[x];i;i=e[i].ne){
			int y=e[i].to;
			if (dis[y]==-1){
				dis[y]=dis[x]+e[i].dis;
				if (dis[y]>dis[ans]) ans=y;
				q[++r]=y;
			}
		}
	}
	return ans;
}

int x=bfs(1);  int y=bfs(x);
\end{lstlisting}

\subsection{强连通分量}
\begin{lstlisting}
int dfn[N],low[N],time;
int scc[N],cnt;
int sta[N],top;
int size[N];

void dfs(int x){
    dfn[x]=low[x]=++time;
    sta[++top]=x;
    forE(i,x){
        int y=e[i].to;
        if (!scc[y]){
            if (!dfn[y]) dfs(y);
            if (low[y]<low[x]) low[x]=low[y];
        }
    }
    if (dfn[x]==low[x]){
        cnt++;
        while (!scc[x]){
            scc[sta[top--]]=cnt;
            size[cnt]++;
        }
    }
}

forto(i,1,n) if (!dfn[i]) dfs(i);
\end{lstlisting}

\subsection{割顶和桥}
\begin{lstlisting}
int dfn[N],low[N],cnt;
int sta[N],top;
int scc[N],scc_cnt;

void dfs(int x, int fa){
	dfn[x]=low[x]=++cnt; sta[++top]=x;
	for(int i=la[x];i;i=e[i].ne){
		int y=e[i].to;
		if (y!=fa){
			if (low[y]==0){
				dfs(y,x);
				low[x]=MIN(low[x],low[y]);
			} else low[x]=MIN(low[x],dfn[y]);
		}
	}
	if (dfn[x]==low[x]){
		scc_cnt++;
		while (sta[top]!=x) scc[sta[top--]]=scc_cnt;
		scc[sta[top--]]=scc_cnt;
	}	
}

dfs(1,0);
\end{lstlisting}

\subsection{网络流}
\begin{lstlisting}
int n,m,la[N],top,q[N],cur[N],dis[N];
struct E{int to,cap,next;} e[M*2];

void add(int a, int b, int c){
	e[++top]=(E){b,c,la[a]}; la[a]=top;
	e[++top]=(E){a,0,la[b]}; la[b]=top;
}
	// remember to set top=1

bool bfs(){
	forto(i,1,n) dis[i]=inf; dis[1]=0;
	int l=1, r=1; q[1]=1;
	while (l<=r){
		int t=q[l++];
		for(int i=la[t];i;i=e[i].next)
		if (e[i].cap && dis[e[i].to]==inf)
			dis[ q[++r]=e[i].to ]=dis[t]+1;
	}
	return dis[n]!=inf;
}

int dinic(int x, int a){
	if (x==n||a==0) return a;
	int flow=0;
	for(int &i=cur[x];i;i=e[i].next)
	if (dis[e[i].to]==dis[x]+1 && e[i].cap){
		int t=dinic(e[i].to,MIN(a,e[i].cap));
		flow+=t; a-=t;
		e[i].cap-=t; e[i^1].cap+=t;
		if (a==0) return flow;
	}
	return flow;
}

int maxflow(){
	int flow=0;
	while (bfs()){
		forto(i,1,n) cur[i]=la[i];
		flow+=dinic(1,inf);
	}
	return flow;
}
\end{lstlisting}

\subsection{费用流}
\begin{lstlisting}
struct E{ int to,cap,dis,ne; } e[M<<1];
int n,la[N],e_top;

void add(int x, int y, int cap, int dis){
	e[++e_top]=(E){y,cap,dis,la[x]}; la[x]=e_top;
	e[++e_top]=(E){x,0,-dis,la[y]}; la[y]=e_top;
}
int dis[N],q[N],l,r,prex[N],prei[N],low[N];
bool vis[N];

bool spfa(){
	forto(i,1,n){ dis[i]=inf; vis[i]=false; }
	dis[1]=0; vis[1]=true; low[1]=inf;
	q[l=r=1]=1;
	while (l<=r){
		int x=q[l++]; vis[x]=false;
		forE(i,x,y,z) if (e[i].cap && dis[x]+z<dis[y]){
			dis[y]=dis[x]+z;
			prex[y]=x; prei[y]=i; low[y]=MIN(low[x],e[i].cap);
			if (vis[y]==false) vis[q[++r]=y]=true;
		}
	}
	return dis[n]!=inf;
}
int flow,cost;

void mcmf(){
	while (spfa()){
		for(int x=n;x!=1;x=prex[x]){
			int i=prei[x];
			e[i].cap-=low[n];
			e[i^1].cap+=low[n];
		}
		flow+=low[n];
		cost+=low[n]*dis[n];
	}
}
\end{lstlisting}

\subsection{hzwer的网络流}
\begin{lstlisting}
// dinic

bool bfs()
{
	int head=0,tail=1;
	for(int i=0;i<=T;i++)h[i]=-1;
	q[0]=0;h[0]=0;
	while(head!=tail)
	{
		int now=q[head];head++;
		for(int i=last[now];i;i=e[i].next)
			if(e[i].v&&h[e[i].to]==-1)
			{
				h[e[i].to]=h[now]+1;
				q[tail++]=e[i].to;
			}
	}
	return h[T]!=-1;
}

int dfs(int x,int f)
{
	if(x==T)return f;
	int w,used=0;
	for(int i=cur[x];i;i=e[i].next)
		if(h[e[i].to]==h[x]+1)
		{
			w=f-used;
			w=dfs(e[i].to,min(w,e[i].v));
			e[i].v-=w;e[i^1].v+=w;
			if(e[i].v)cur[x]=i;
			used+=w;if(used==f)return f;
		}
	if(!used)h[x]=-1;
	return used;
}

void dinic()
{
	while(bfs())
	{
		for(int i=0;i<=T;i++)
			cur[i]=last[i];
		ans+=dfs(0,inf);
	}
} 

// spfa

bool spfa()
{
	for(int i=0;i<=T;i++)dis[i]=inf;
	int head=0,tail=1;
	dis[0]=0;q[0]=0;inq[0]=1;
	while(head!=tail)
	{
		int now=q[head++];if(head==1601)head=0;
		for(int i=last[now];i;i=e[i].next)
			if(e[i].v&&e[i].c+dis[now]<dis[e[i].to])
			{
				dis[e[i].to]=e[i].c+dis[now];
				from[e[i].to]=i;
				if(!inq[e[i].to])
				{
					inq[e[i].to]=1;
					if(dis[e[i].to]<dis[q[head]])
					{
						head--;if(head==-1)head=1600;
						q[head]=e[i].to;
					}
					else
					{
						q[tail++]=e[i].to;
						if(tail==1601)tail=0;
					}
				}
			}
		inq[now]=0;
	}
	if(dis[T]==inf)return 0;
	return 1;
}

void mcf()
{
	int x=inf;
	for(int i=from[T];i;i=from[e[i].from])
		x=min(e[i].v,x);
	for(int i=from[T];i;i=from[e[i].from])
	{
		ans+=x*e[i].c;
		e[i].v-=x;e[i^1].v+=x;
	}
}

// zkw

bool spfa()
{
    memset(mark,0,sizeof(mark));
    for(int i=0;i<=T;i++)d[i]=-1;
    int head=0,tail=1;
    q[0]=T;mark[T]=1;d[T]=0;
    while(head!=tail)
    {
		int now=q[head];head++;if(head==605)head=0;
		for(int i=last[now];i;i=e[i].next)
			if(e[i^1].v&&d[now]+e[i^1].c>d[e[i].to])
			{
				d[e[i].to]=d[now]+e[i^1].c;
				if(!mark[e[i].to])
				{
					mark[e[i].to]=1;
					q[tail++]=e[i].to;
					if(tail==605)tail=0;
				}
			}
		mark[now]=0;
    }
    return d[0]!=-1;
}

int dfs(int x,int f)
{
    mark[x]=1;
    if(x==T)return f;
    int w,used=0;
    for(int i=last[x];i;i=e[i].next)
		if(d[e[i].to]==d[x]-e[i].c&&e[i].v&&!mark[e[i].to])
		{
			w=f-used;
			w=dfs(e[i].to,min(w,e[i].v));
			ans+=w*e[i].c;
			e[i].v-=w;e[i^1].v+=w;
			used+=w;if(used==f)return f;
		}
    return used;
}

void zkw()
{
    while(spfa())
    {
		mark[T]=1;
		while(mark[T])
		{
			memset(mark,0,sizeof(mark));
			dfs(0,inf);
		}
    }
}
\end{lstlisting}

\subsection{欧拉回路}
\begin{lstlisting}
#include<cstdlib>
#include<cstdio>

#define forto(i,a,b) for(int i=(a);i<=(b);i++)
#define fordown(i,a,b) for(int i=(a);i>=(b);i--)
#define forE(i,x) for(int i=la[x];i;i=e[i].ne)

const int N=100100, M=200200;

struct E{ int to,ne; } e[M<<1];
int t,n,m,la[N],e_top;
int in[N],out[N];

void add(int x, int y){
	out[x]++; in[y]++;
	e[++e_top]=(E){y,la[x]}; la[x]=e_top;
}

int sta[M],top;
bool vis[M<<1];

void dfs(int x){
	for(int i=la[x];i;i=la[x]){
		la[x]=e[i].ne;
		if (!vis[i]){
			if (t==1) vis[i]=vis[i^1]=true; else vis[i]=true;
			la[x]=e[i].ne;
		
			dfs(e[i].to);
		
			if (t==1) sta[++top]=(i&1)?(-(i>>1)):(i>>1);
				else sta[++top]=i;
		}
	}
}

int main(){
	scanf("%d",&t);
	scanf("%d%d",&n,&m);
	if (m==0){
		printf("YES");
		return 0;
	}
	
	if (t==1) e_top=1;
	forto(i,1,m){
		int x,y; scanf("%d%d",&x,&y);
		if (t==1){ add(x,y); add(y,x); }
		if (t==2) add(x,y);
	}
	
	if (t==1)
	forto(i,1,n) if (in[i]&1){
		printf("NO");
		return 0;
	}
	
	if (t==2)
	forto(i,1,n) if (in[i]!=out[i]){
		printf("NO");
		return 0;
	}
	
	if (t==1) dfs(e[2].to); else dfs(e[1].to);
	
	if (top!=m){
		printf("NO");
		return 0;
	}
	
	printf("YES\n");
	fordown(i,top,1) printf("%d ",sta[i]);
	return 0;
}
\end{lstlisting}

\subsection{带花树}
\begin{lstlisting}
#include<cstdlib>
#include<cstdio>

#define forto(i,a,b) for(int i=(a);i<=(b);i++)
#define fordown(i,a,b) for(int i=(a);i>=(b);i--)
#define forE(i,x) for(int i=la[x];i;i=e[i].ne)
#define add(x,y) { e[++e_top]=(E){y,la[x]}; la[x]=e_top; }

const int N=550;

struct E{ int to,ne; } e[N*N];
int n,m,la[N],e_top;

int f[N];
int find(int x){ return f[x]==x?x:f[x]=find(f[x]); }

int mat[N],pre[N],cond[N],q[N],l,r;

int vis[N],vt;
int lca(int x, int y){
	vt++; x=find(x); y=find(y);
	while (vis[x]!=vt){
		if (x){ vis[x]=vt; x=find(pre[mat[x]]); }
		int z=x; x=y; y=z;
	}
	return x;
}

void blossom(int x, int y, int g){
	while (find(x)!=g){
		pre[x]=y;
		if (cond[mat[x]]==1) cond[q[++r]=mat[x]]=0;
		if (f[x]==x) f[x]=g;
		if (f[mat[x]]==mat[x]) f[mat[x]]=g;
		y=mat[x]; x=pre[y];
	}
}

int match(int s){
	forto(i,1,n){ cond[i]=-1; pre[i]=0; f[i]=i; }
	cond[q[l=r=1]=s]=0;
	while (l<=r){
		int x=q[l++];
		forE(i,x){
			int y=e[i].to;
			if (cond[y]==-1){
				if (mat[y]==0){
					while (x){
						int t=mat[x];
						mat[x]=y; mat[y]=x;
						y=t; x=pre[y];
					}
					return true;
				}
				cond[y]=1; pre[y]=x;
				cond[q[++r]=mat[y]]=0;
			} else if (find(x)!=find(y) && cond[y]==0){
				int g=lca(x,y); blossom(x,y,g); blossom(y,x,g);
			}
		}
	}
	return false;
}

int main(){
	scanf("%d%d",&n,&m);
	int ans=0;
	while (m--){
		int x,y; scanf("%d%d",&x,&y);
		add(x,y); add(y,x);
	}
	forto(i,1,n) if (!mat[i]&&match(i)) ans++;
	printf("%d\n",ans);
	forto(i,1,n) printf("%d ",mat[i]);
	return 0;
}
\end{lstlisting}

\subsection{KM}
\begin{lstlisting}
#include<cstdlib>
#include<cstdio>

#define forto(i,a,b) for(int i=(a);i<=(b);i++)
#define fordown(i,a,b) for(int i=(a);i>=(b);i--)

#define MIN(a,b) ((a)<(b)?(a):(b))
#define MAX(a,b) ((a)>(b)?(a):(b))
#define cmin(a,b) ((b)<(a)?(a)=(b):(a))
#define cmax(a,b) ((b)>(a)?(a)=(b):(a))

typedef long long LL;
const int N=500, inf=0x7fffffff;

int n,fx[N],fy[N],pre[N];
LL w[N][N],lx[N],ly[N],sla[N];
bool vx[N],vy[N],a[N][N];
int q[N],l,r;

bool check(int x, int y){
	if (!fy[y]){
		while (x){
			int t=fx[x];
			fx[x]=y; fy[y]=x;
			y=t; x=pre[y];
		}
		return true;
	}
	vy[y]=true; pre[y]=x;
	vx[q[++r]=fy[y]]=true;
	return false;
}

void bfs(int s){
	forto(i,1,n){ vx[i]=vy[i]=false; sla[i]=inf; }
	vx[q[l=r=1]=s]=true;
	while (true){
		while (l<=r){
			int x=q[l++];
			forto(y,1,n) if (!vy[y]){
				LL t=lx[x]+ly[y]-w[x][y];
				if (t==0 && check(x,y)) return;
				if (t && t<sla[y]){ sla[y]=t; pre[y]=x; }
			}
		}
		int d=inf;
		forto(y,1,n) if (!vy[y]) cmin(d,sla[y]);
		forto(x,1,n) if (vx[x]) lx[x]-=d;
		forto(y,1,n) if (vy[y]) ly[y]+=d; else sla[y]-=d;
		forto(y,1,n) if (!vy[y] && !sla[y] && check(pre[y],y)) return;
	}
}

void KM(){
	forto(x,1,n){
		lx[x]=w[x][1];
		forto(y,2,n) cmax(lx[x],w[x][y]);
	}
	forto(s,1,n) bfs(s);
}

int main(){
	int nl,nr,m;
	scanf("%d%d%d",&nl,&nr,&m);
	while (m--){
		int x,y,z; scanf("%d%d%d",&x,&y,&z);
		w[x][y]=z; a[x][y]=true;
	}
	n=MAX(nl,nr);
	
	KM();
	LL ans=0;
	forto(i,1,n) ans+=lx[i];
	forto(j,1,n) ans+=ly[j];
	printf("%lld\n",ans);
	forto(i,1,nl) if (a[i][fx[i]]) printf("%d ",fx[i]); else printf("0 ");
	return 0;
}
\end{lstlisting}

\subsection{最小树形图}
\begin{lstlisting}
#include<cstdlib>
#include<cstdio>
#include<cmath>

#define forto(i,a,b) for(int i=(a);i<=(b);i++)
#define fordown(i,a,b) for(int i=(a);i>=(b);i--)

#define MIN(a,b) ((a)<(b)?(a):(b))
#define MAX(a,b) ((a)>(b)?(a):(b))

const int N=110, M=40000, inf=0x7fffffff;
struct E{ int to,ne; double dis; } e[M];
int n,m,la[N],g[N],e_top;

void add1(int x, int y, double z){
	e[++e_top]=(E){y,g[x],z}; g[x]=e_top;
	e[++e_top]=(E){x,la[y],z}; la[y]=e_top;
}

void add2(int x, int y, double z){
	e[++e_top]=(E){y,la[x],z}; la[x]=e_top;
}

void build_graph(){
	static int x[N],y[N];
	forto(i,1,n) la[i]=g[i]=0;
	e_top=0;
	forto(i,1,n) scanf("%d%d",&x[i],&y[i]);
	forto(i,1,m){
		int a,b; scanf("%d%d",&a,&b);
		add1( a,b,sqrt( (x[a]-x[b])*(x[a]-x[b]) + (y[a]-y[b])*(y[a]-y[b]) ) );
	}
}

int q[N],l,r;
bool vis[N];

bool check(){
	forto(i,1,n) vis[i]=false;
	q[l=r=1]=1; vis[1]=true;
	while (l<=r){
		int x=q[l++];
		for(int i=g[x];i;i=e[i].ne){
			int y=e[i].to;
			if (vis[y]==false){
				vis[y]=true;
				q[++r]=y;
			}
		}
	}
	return r==n;
}

int f[N];

int find(int x){
	return f[x]==x?x:f[x]=find(f[x]);
}

bool ok[N];
int sta[N],top;
double cho[N];

double solve(){
	double ans=0;
	forto(i,1,n) f[i]=i;
	forto(i,1,n) ok[i]=vis[i]=false;
	ok[1]=true;
	
	forto(t,1,n){
		vis[sta[top=1]=find(t)]=true;
		while (ok[sta[top]]==false){
			int x=sta[top], y=0; double z=1e100;
			for(int i=la[x];i;i=e[i].ne)
			if (find(e[i].to)!=x && e[i].dis<z){
				z=e[i].dis;
				y=e[i].to;
			}
			
			y=find(y);
			
			cho[x]=z;
			ans+=z;
			
			if (vis[y]){
				for(int i=la[y];i;i=e[i].ne) e[i].dis-=cho[y];
				while (sta[top]!=y){
					vis[ x=sta[top--] ]=false;
					for(int i=la[x];i;i=e[i].ne) add2(y, e[i].to, e[i].dis-cho[x]);
					f[x]=y;
				}
			} else vis[sta[++top]=y]=true;
		}
		while (top){
			ok[sta[top]]=true;
			vis[sta[top--]]=false;
		}
	}
	return ans;
}
			
int main(){
	while (scanf("%d%d",&n,&m)>0){
		build_graph();	
		if (check()) printf("%.2f\n",solve()); else printf("poor snoopy\n");
	}
	return 0;
}
\end{lstlisting}

\subsection{最小树形图输出路径}
\begin{lstlisting}
using namespace std;  
  
const int INF=0x3f3f3f3f;  
const int maxn=2001000;  
  
int n,m;  
  
struct Edge  
{  
    int u,v,cost,id,ru,rv,rcost;  
}edge[maxn];  
  
void add_Edge(int id,int u,int v,int c)  
{  
    edge[id].id=id;  
    edge[id].u=edge[id].ru=u;  
    edge[id].v=edge[id].rv=v;  
    edge[id].cost=edge[id].rcost=c;  
}  
  
int pre[maxn],id[maxn],vis[maxn],in[maxn];  
  
//// !!!!  
int preid[maxn],useE[maxn];  
int eA[maxn],eD[maxn];  
int ex;  
  
int zhuliu(int root,int n,int m,Edge edge[])  
{  
    int ex=m,res=0;  
    while(true)  
    {  
        for(int i=0;i<n;i++) in[i]=INF;  
        for(int i=0;i<m;i++)  
        {  
            if(edge[i].u!=edge[i].v&&edge[i].cost<in[edge[i].v])  
            {  
                pre[edge[i].v]=edge[i].u;  
                in[edge[i].v]=edge[i].cost;  
  
                //// !!!!  
                preid[edge[i].v]=edge[i].id;  
            }  
        }  
        for(int i=0;i<n;i++)  
            if(i!=root&&in[i]==INF) return -1;  
        int tn=0;  
        memset(id,-1,sizeof(id));  
        memset(vis,-1,sizeof(vis));  
        in[root]=0;  
        for(int i=0;i<n;i++)  
        {  
            res+=in[i];  
            int v=i;  
            //// !!!!  
            if(i!=root) useE[preid[i]]++;  
            while(vis[v]!=i&&id[v]==-1&&v!=root)  
            {  
                vis[v]=i; v=pre[v];  
            }  
            if(v!=root&&id[v]==-1)  
            {  
                for(int u=pre[v];u!=v;u=pre[u]) id[u]=tn;  
                id[v]=tn++;  
            }  
        }  
        if(tn==0) break;  
        for(int i=0;i<n;i++)  
            if(id[i]==-1) id[i]=tn++;  
        for(int i=0;i<m;i++)  
        {  
            int v=edge[i].v;  
            edge[i].u=id[edge[i].u];  
            edge[i].v=id[edge[i].v];  
            if(edge[i].u!=edge[i].v)  
            {  
                edge[i].cost-=in[v];  
                //// !!!!  
                eA[ex]=edge[i].id;  
                eD[ex]=preid[v];  
                edge[i].id=ex;  
                ex++;  
            }  
        }  
        n=tn;  
        root=id[root];  
    }  
  
    //// !!!!  
    for(int i=ex-1;i>=m;i--)  
    {  
        if(useE[i])  
        {  
            useE[eA[i]]++; useE[eD[i]]--;  
        }  
    }  
  
    return res;  
}  
  
int main()  
{  
    freopen("input.txt","r",stdin);  
    freopen("output.txt","w",stdout);  
      
    scanf("%d%d",&n,&m);  
  
    for(int i=0,a,b,c;i<m;i++)  
    {  
        scanf("%d%d%d",&a,&b,&c);  
        a--; b--;  
        add_Edge(i,a,b,c);  
    }  
  
    int lens = zhuliu(0,n,m,edge);  
  
    if(lens==0||lens==-1) { printf("%d\n",lens); return 0; }  
  
    printf("%d\n",lens);  
    for(int i=0;i<m;i++)  
    {  
        if(useE[i]&&edge[i].rcost)  
            printf("%d ",i+1);  
    }  
    putchar(10);  
  
    return 0;  
}  
\end{lstlisting}

\subsection{2-SAT}
\begin{lstlisting}
#include<cstdio>
#include<vector>
#include<stack>
using namespace std;
const int maxn=600;

struct twosat{
	int n;
	vector<int> g[maxn*2];
	bool mark[maxn*2];
	stack<int> s;
	
	void add(int x,int xx,int y,int yy){
		x=x*2+xx;
		y=y*2+yy;
		g[x^1].push_back(y);
		g[y^1].push_back(x);
	}
	
	bool dfs(int x){
		if (mark[x^1]) return false;
		if (mark[x]) return true;
		mark[x]=true;
		s.push(x);
		for (int i=0; i<g[x].size(); i++)
			if (!dfs(g[x][i])) return false;
		return true;
	}
	
	bool solve(){
		for (int i=0;i<n*2;i+=2)
		if (!mark[i] && !mark[i+1]){
			while (!s.empty()) s.pop();
			if (!dfs(i)){
				while (!s.empty()){
					mark[s.top()]=false;
					s.pop();
				}
				if (!dfs(i+1)) return false;
			}
		}
		return true;
	}
} g;

int a[maxn],b[maxn];

int main(){
	int n,m;
	scanf("%d %d",&n,&m);
	for (int i=1;i<=m;i++){
		scanf("%d %d",&a[i],&b[i]);
		if (a[i]>b[i]){ int c=a[i]; a[i]=b[i]; b[i]=c; }
	}	
	g.n=m;	
	for (int i=1;i<=m;i++)
	for (int j=1;j<=m;j++)
	if ( a[i]<a[j] && a[j]<b[i] && b[i]<b[j] ){	
		g.add(i,0,j,0);
		g.add(i,1,j,1);
	}
	if (g.solve()) printf("panda is telling the truth..."); else printf("the evil panda is lying again");
	return 0;
}
\end{lstlisting}

\subsection{稳定婚姻问题}
\begin{lstlisting}
#include<cstdio>
#include<cctype>
#include<queue>
#include<cstring>
using namespace std;

char readchar(){
	int i=getchar();
	while (!isalpha(i)) i=getchar();
	return i;
}

const int maxn=50;

int list[maxn][maxn], order[maxn][maxn], next[maxn];
int a[maxn],b[maxn];
int na[200],nb[200],name[200];
queue<int> q;

void init(){
	memset(next,0,sizeof(next));
	memset(a,0,sizeof(a));
	memset(b,0,sizeof(b));
	memset(na,0,sizeof(na));
}	

void engage(int x,int y){
	int m=b[y];
	if (m){
		a[m]=0;
		q.push(m);
	}
	a[x]=y; b[y]=x;
}	

int main(){
	int t; scanf("%d",&t);
	while (t--){
		init();
		int n;
		scanf("%d",&n);
				
		for (int i=1;i<=n;i++){
			char j=readchar();
			na[j]=i;
		}
		for (int i=1;i<=n;i++){
			char j=readchar();
			nb[j]=i;
			name[i]=j;
		}
		for (int i=1;i<=n;i++){
			char c=readchar();
			for (int j=1;j<=n;j++){
				char d=readchar();
				list[na[c]][j]=nb[d];
			}
		}
		for (int i=1;i<=n;i++){
			char c=readchar();
			for (int j=1;j<=n;j++){
				char d=readchar();
				order[nb[c]][na[d]]=j;
			}
		}
		
		for (int i=1;i<=n;i++) q.push(i);
		
		while (!q.empty()){
			int i=q.front(); q.pop();
			int j=list[i][++next[i]];
			if (!b[j]) engage(i,j);
			else if(order[j][i]<order[j][b[j]]) engage(i,j);
			else q.push(i);
		}
		
		for (char i='A';i<='z';i++)
		if (na[i]){
			char j=name[a[na[i]]];
			printf("%c %c\n",i,j);
		}
		printf("\n");
	}
	return 0;
}
\end{lstlisting}

\subsection{hzwer的K短路}
\begin{lstlisting}
#include<ext/pb_ds/priority_queue.hpp>
#define pa pair<int,int>
#define inf 2000000000
using namespace std;
using namespace __gnu_pbds;
inline int read()
{
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
typedef __gnu_pbds::priority_queue<pa,greater<pa> > heap;
int n,m,K,cnt,cnt2;
int ans[105];
int d[10005],g[10005],tim[10005];
int last[10005],last2[10005];
heap q;
heap::point_iterator id[10005];
struct edge{int to,next,v;}e[10005],ed[10005];
void insert(int u,int v,int w)
{
	e[++cnt].to=v;e[cnt].next=last[u];last[u]=cnt;e[cnt].v=w;
	ed[++cnt2].to=u;ed[cnt].next=last2[v];last2[v]=cnt2;ed[cnt2].v=w;
}
void dijkstra()
{
	for(int i=1;i<=n;i++)d[i]=inf;
	d[1]=0;
	id[1]=q.push(make_pair(0,1));
	while(!q.empty())
	{
		int now=q.top().second;q.pop();
		for(int i=last2[now];i;i=ed[i].next)
			if(ed[i].v+d[now]<d[ed[i].to])
			{
				d[ed[i].to]=d[now]+ed[i].v;
				if(id[ed[i].to]!=0)
					q.modify(id[ed[i].to],make_pair(d[ed[i].to],ed[i].to));
				else id[ed[i].to]=q.push(make_pair(d[ed[i].to],ed[i].to));
			}
	}
}
void astar()
{
    if(d[n]==inf)return;
    q.push(make_pair(d[n],n));
	while(!q.empty())
	{
		int now=q.top().second,dis=q.top().first;q.pop();
		tim[now]++;
		if(now==1)ans[tim[now]]=dis;
		if(tim[now]<=K)
			for(int i=last[now];i;i=e[i].next)
				q.push(make_pair(dis-d[now]+d[e[i].to]+e[i].v,e[i].to));
	}
}
int main()
{
	n=read();m=read();K=read();
	for(int i=1;i<=m;i++)
	{
		int u=read(),v=read(),w=read();
		insert(u,v,w);
	}
	dijkstra();
	astar();
	for(int i=1;i<=K;i++)
		if(ans[i])printf("%d\n",ans[i]);
		else puts("-1");
	return 0;
}
\end{lstlisting}


\section{数据结构}

\subsection{哈希表}
\begin{lstlisting}
const int H=(1<<20)-1;
struct hash_map{
	int la[1<<20],top;
	struct E { LL key; int da,ne; } e[int(1e6)];
	IL void clear(){
		memset(la,0,sizeof(la)); top=0;
	}
	IL bool count(LL k){
		static int i; i=la[k&H];
		while (i&&e[i].key!=k) i=e[i].ne;
		return i;
	}
	IL int& OP[] (LL k){
		static int h,i; i=la[h=k&H];
		while (i&&e[i].key!=k) i=e[i].ne;
		if (!i){ e[i=++top]=(E){k,0,la[h]}; la[h]=top; }
		return e[i].da;
	}
};
\end{lstlisting}

\subsection{RMQ}
\begin{lstlisting}
inline void rmq(int n){
	for(int i=0,k=1; k<n; k<<=1,i++)
	forto(j,1,n-k) f[j][i+1]=MAX(f[j][i],f[j+k][i]);
}
inline int getrmq(int l, int r){
	int len=r-l+1, i=0, k=1;
	while (k<<1<=len){ k<<=1; i++; }
	return MAX(f[l][i],f[r-k+1][i]);
}
\end{lstlisting}

\subsection{树状数组}
\begin{lstlisting}
inline int sum(int x){
	int s=0;
	while (x>0){ s+=a[x]; x-=x&-x; }
	return s;
}
inline void add(int x, int d){
	while (x<=n){ a[x]+=d; x+=x&-x; }
}
\end{lstlisting}

\subsection{树链剖分}
\begin{lstlisting}
void find(int x, int father, int depth){
    size[x]=1; dep[x]=depth; son[x]=0; fa[x]=father;
    int maxsize=0;
    for (int i=0; i<g[x].size(); i++)
    if (g[x][i]!=father){
        int y=g[x][i];
        find(y,x,depth+1);
        size[x]+=size[y];
        if (size[y]>maxsize){
            maxsize=size[y];
            son[x]=y;
        }
    }
}

void connect(int x, int anc){
    tid[x]=++label; top[x]=anc;
    if (son[x]) connect(son[x], anc);
    for (int i=0; i<g[x].size(); i++){
        int y=g[x][i];
        if (y!=son[x] && y!=fa[x]) connect(y,y);
    }
}

int getsum(int x, int y){
    int sumnum=0;
    while (top[x]!=top[y]){
        if (dep[top[x]]<dep[top[y]]) { int z=x; x=y; y=z; }
        sumnum+=seq.getsum(tid[top[x]],tid[x]);
        x=fa[top[x]];
    }
    if (dep[x]<dep[y]) sumnum+=seq.getsum(tid[x],tid[y]);
        sumnum+=seq.getsum(tid[y],tid[x]);
    return sumnum;
}
\end{lstlisting}

\subsection{LCT}
\begin{lstlisting}
int n,fa[maxn],ch[maxn][2];
inline void ir(int x){ return ch[fa[x]][0]!=x && ch[fa[x]][1]!=x; }
inline void nt(int x){ return ch[fa[x]][1]==x; }
inline void ud(int x){ ... }
inline void pd(int x){ ... }

inline void rtt(int x){
	int y=fa[x], z=fa[y], bool p=nt(x);
	if (!ir(y)) ch[z][nt(y)]=x;
	fa[ch[x][!p]]=y; fa[y]=x; fa[x]=z;
	ch[y][p]=ch[x][!p]; ch[x][!p]=y;
	ud(y);
}
inline void splay(int x){
	static int sta[maxn],top;
	sta[top=1]=x;
	for(int y=x;!ir(y);y=fa[y]) sta[++top]=fa[y];
	while (top) pd(sta[top--]);
	while (!ir(x)){
		int y=fa[x];
		if (!ir(y)) rtt(nt(x)^nt(y)?x:y);
		rtt(x);
	}
	ud(x);
}
inline void access(int x){
	int t=0,y=x;
	while(x){
		splay(x); ch[x][1]=t;
		t=x; x=fa[x];
	}
	splay(y);
}

inline void link(int c, int f){ access(c); fa[c]=f; }
inline void cut(int x){ access(x); fa[ch[x][0]]=0; ch[x][0]=0; ud(x); }
inline void makeroot(int x){ access(x); rev[x]^=1; }

inline int find(int x){
	access(x);
	int y=x; while (ch[y][0]) y=ch[y][0];
	return y;
}
\end{lstlisting}

\subsection{LCT 不换根}
\begin{lstlisting}
//bzoj2002

#include<cstdio>

const int N=210000;

int fa[N],ch[N][2],size[N];

inline bool ir(int x){ return ch[fa[x]][0]!=x&&ch[fa[x]][1]!=x; }
inline bool nt(int x){ return ch[fa[x]][1]==x; }
inline void ud(int x){ size[x]=size[ch[x][0]]+size[ch[x][1]]+1; }

void rtt(int x){
	int y=fa[x], z=fa[y]; bool p=nt(x);
	if (!ir(y)) ch[z][nt(y)]=x;
	fa[y]=x; fa[x]=z; fa[ch[x][!p]]=y;
	ch[y][p]=ch[x][!p]; ch[x][!p]=y;
	ud(y);
}

void splay(int x){
	while (!ir(x)){
		int y=fa[x];
		if (!ir(y)) rtt(nt(x)^nt(y)?x:y);
		rtt(x);
	}
	ud(x);
}

void access(int x){
	int y=x, t=0;
	while (x){
		splay(x); ch[x][1]=t;
		t=x; x=fa[x];
	}
	splay(y);
}	
	
void link(int c, int f){ access(c); fa[c]=f; }
void cut(int x){ access(x); fa[ch[x][0]]=0; ch[x][0]=0; }

int main(){
	int n; scanf("%d",&n);
	for (int i=1;i<=n;i++) size[i]=1;
	for (int i=1;i<=n;i++){
		int k; scanf("%d",&k);
		if (i+k<=n) link(i,i+k);
	}
	int m; scanf("%d",&m);
	while (m--){
		int i,j,k; scanf("%d%d",&i,&j); j++;
		if (i==1){
			access(j);
			printf("%d\n",size[j]);
		}
		if (i==2){
			scanf("%d",&k);
			cut(j);
			if (j+k<=n) link(j,j+k);
		}
	}
	return 0;
}
\end{lstlisting}

\subsection{LCT 换根}
\begin{lstlisting}
//bzoj2049

#include<cstdlib>
#include<cstdio>
#define swap(a,b) {swp=a;a=b;b=swp;}
int swp;

inline void readint(int &x){
	x=0; char c=getchar();
	while (c<'0'||c>'9') c=getchar();
	while (c>='0'&&c<='9'){ x=x*10+c-'0'; c=getchar(); }
}

const int maxn=11000;

int n,m,fa[maxn],ch[maxn][2],sta[maxn],top;
bool rev[maxn];

inline bool ir(int x){ return ch[fa[x]][0]!=x && ch[fa[x]][1]!=x; }
inline bool nt(int x){ return ch[fa[x]][1]==x; }

inline void pd(int x){
	if (rev[x]){
		rev[ch[x][0]]^=1; rev[ch[x][1]]^=1;
		swap(ch[x][0],ch[x][1]); rev[x]=false;
	}
}

inline void rtt(int x){
	int y=fa[x], z=fa[y]; bool p=nt(x);
	if (!ir(y)) ch[z][nt(y)]=x;
	fa[ch[x][!p]]=y; fa[y]=x; fa[x]=z;
	ch[y][p]=ch[x][!p]; ch[x][!p]=y;
}

inline void splay(int x){
	top=0; sta[++top]=x;
	for (int y=x;!ir(y);y=fa[y]) sta[++top]=fa[y];
	while (top) pd(sta[top--]);
	while (!ir(x)){
		int y=fa[x];
		if (!ir(y)) rtt(nt(x)^nt(y)?x:y);
		rtt(x);
	}
}

inline void access(int x){
	int t=0;
	while (x){
		splay(x); ch[x][1]=t;
		t=x; x=fa[x];
	}
} 

inline void makeroot(int x){ access(x); splay(x); x[rev]^=1; }

inline void link(int x, int y){ makeroot(x); fa[x]=y; }

inline void cut(int x, int y){ makeroot(x); access(y); splay(y); ch[y][0]=fa[x]=0; }

inline int find(int x){
	access(x); splay(x);
	int y=x; while (ch[y][0]) y=ch[y][0];
	return y;
};	

int main(){
	readint(n); readint(m);
	while (m--){
		char s[10]; scanf("%s",s);
		int x,y; readint(x); readint(y);
		if (s[0]=='Q'){
			if (find(x)==find(y)) printf("Yes\n"); else printf("No\n");
		}
		if (s[0]=='C') link(x,y);
		if (s[0]=='D') cut(x,y);
	}
	return 0;
}
\end{lstlisting}

\subsection{左偏树}
\begin{lstlisting}
int a[N],lc[N],rc[N],d[N],size[N];

int merge(int x, int y){
	if (x==0) return y;
	if (y==0) return x;
	if (a[x]<a[y]){ int z=x; x=y; y=z; }
	rc[x]=merge(rc[x],y);
	if (d[rc[x]]>d[lc[x]]){ int t=lc[x]; lc[x]=rc[x]; rc[x]=t; }
	d[x]=d[rc[x]+1];
	size[x]=size[lc[x]]+size[rc[x]]+1;
	return x;
}

int pop(int x){
	return merge(lc[x],rc[x]);
}
\end{lstlisting}

\subsection{可持久化并查集}
\begin{lstlisting}
const int N=10000000;
int lc[N],rc[N],f[N],top;

int get(int x, int l, int r, int t){
	if (l==r) return f[x];
	int m=(l+r)>>1;
	if (t<=m) return get(lc[x],l,m,t);
	return get(rc[x],m+1,r,t);
}

int change(int x, int l, int r, int t, int d){
	if (l==r){
		f[++top]=d;
		return top;
	}
	int y=++top; lc[y]=lc[x]; rc[y]=rc[x];
	int m=(l+r)>>1;
	if (t<=m) lc[y]=change(lc[y],l,m,t,d);
		else rc[y]=change(rc[y],m+1,r,t,d);
	return y;
}

void build(int x, int l, int r){
	if (l==r){ f[x]=l; return; }
	int m=(l+r)>>1;
	build(lc[x]=++top,l,m);
	build(rc[x]=++top,m+1,r);
}
	
int a[200100],n,m;

int find(int i, int x){
	int fx=get(a[i],1,n,x);
	if (x==fx) return x;
	fx=find(i,fx);
	a[i]=change(a[i],1,n,x,fx);
	return fx;
}
\end{lstlisting}

\subsection{可持久化treap}
\begin{lstlisting}
#include<cstdlib>
#include<cstdio>
#define MIN(a,b) ((a)<(b)?(a):(b))
using namespace std;

struct treap{
	int data,fix;
	int size,add,min;
	bool flip;
	treap *l,*r;
	treap(int data):data(data), size(1), fix(rand()), l(NULL), r(NULL), add(0), min(data), flip(false){}
	
	void update(){
		size=(l?l->size:0)+(r?r->size:0)+1;
		min=data;
		if (l) min=MIN(min,l->min);
		if (r) min=MIN(min,r->min);
		min+=add;
	}
	
	void pushdown(){
		if (add){
			if (l) l->add+=add;
			if (r) r->add+=add;
			data+=add;
			add=0;
		}
		if (flip){
			flip=false;
			treap *t;
			t=l; l=r; r=t;
			if (l) l->flip=!l->flip;
			if (r) r->flip=!r->flip;
		}
		if (l) l->update();
		if (r) r->update();
	}
};

inline int size(treap *a){ return a?a->size:0; }

treap *merge(treap *a, treap *b){
	if (a==NULL) return b;
	if (b==NULL) return a;
	if (a->fix > b->fix){
		a->pushdown();
		a->r=merge(a->r,b);
		a->update();
		return a;
	} else {
		b->pushdown();
		b->l=merge(a,b->l);
		b->update();
		return b;
	}
}

void split(treap *x, int s, treap *&a, treap *&b){
	if (s<=0) { a=NULL; b=x; return; }
	if (s>=size(x)) { a=x; b=NULL; return; }
	x->pushdown();
	if (s<=size(x->l)) {
		split(x->l,s,a,b);
		x->l=b; b=x;
	} else {
		split(x->r,s-size(x->l)-1,a,b);
		x->r=a; a=x;
	}
	x->update();
	return;
}

void split3(treap *root, int x, int y, treap *&a, treap *&b, treap *&c){
	treap *t;
	split(root,x-1,a,t);
	split(t,y-x+1,b,c);
}

treap *merge3(treap *a, treap *b, treap *c){
	treap *t=merge(a,b);
	return merge(t,c);
}

treap *newnode(int data){
	treap *t=new treap(data);
	return t;
}

treap *root;

int main(){
	int n; scanf("%d",&n);
	for (int i=1;i<=n;i++){
		int data; scanf("%d",&data);
		root=merge(root,newnode(data));
	}
	
	int m; scanf("%d",&m);
	for (int i=1;i<=m;i++){
		int x,y,z;
		treap *a,*b,*c;
		char s[20]; scanf("%s",s);
		
		if (s[0]=='A'){
			scanf("%d%d%d",&x,&y,&z);
			split3(root,x,y,a,b,c);
			if (b) b->add+=z;
			b->update();
			root=merge3(a,b,c);
		}
		
		if (s[0]=='R' && s[3]=='E'){
			scanf("%d%d",&x,&y);
			split3(root,x,y,a,b,c);
			if (b) b->flip=!b->flip;
			root=merge3(a,b,c);
		}
		
		if (s[0]=='R' && s[3]=='O'){
			scanf("%d%d%d",&x,&y,&z);
			split3(root,x,y,a,b,c);
			if (b){
				z%=size(b);
				if (z<0) z+=size(b);
				treap *t1,*t2;
				split(b,size(b)-z,t1,t2);
				b=merge(t2,t1);
			}
			root=merge3(a,b,c);
		}
		
		if (s[0]=='I'){
			scanf("%d%d",&x,&y);
			split(root,x,a,b);
			root=merge(merge(a,newnode(y)),b);
		}
		
		if (s[0]=='D'){
			scanf("%d",&x);
			split3(root,x,x,a,b,c);
			if (b) delete b;
			root=merge(a,c);
		}
		
		if (s[0]=='M'){
			scanf("%d%d",&x,&y);
			split3(root,x,y,a,b,c);
			b->update();
			printf("%d\n",b->min);
			root=merge3(a,b,c);
		}
	}
	return 0;
}
\end{lstlisting}

\subsection{pq的妙用1}
\begin{lstlisting}
IL int gcd(int a, int b){
	while (b){ int c=a%b; a=b; b=c; }
	return a;
}

struct data { int a,b,x,y; };

IL bool OP< (const data &a, const data &b){
	return LL(a.x)*LL(b.y) > LL(a.y)*LL(b.x);
}

const int N=120000;
int n,L,d[N],v[N];

IL data get(int a, int b){
	int dd=d[a]-d[b];
	int vv=v[b]-v[a];
	if (vv<0) { vv=-vv; dd=-dd; }
	if (dd<0) dd+=L;
	return (data){a,b,dd,vv};
}

int l[N],r[N];
std::priority_queue<data> q;
bool ok[N];
int ansx,ansy;

struct co { int num,dis; } c[N];
IL bool comp(const co &a, const co &b) { return a.dis<b.dis; }

IL void solve(){
	scanf("%d%d",&n,&L);
	forto(i,1,n) scanf("%d",&d[i]);
	forto(i,1,n) scanf("%d",&v[i]);
	
	forto(i,1,n) c[i]=(co){i,d[i]};
	std::sort(c+1,c+n+1,comp);
	
	forto(i,2,n) l[c[i].num]=c[i-1].num;
	l[c[1].num]=c[n].num;
	
	forto(i,1,n-1) r[c[i].num]=c[i+1].num;
	r[c[n].num]=c[1].num;
	
	forto(i,1,n) ok[i]=true;
	
	while (!q.empty()) q.pop();
	forto(i,1,n) q.push(get(i,r[i]));
	
	forto(ttt,2,n){
		data da=q.top(); q.pop();
		
		while (!ok[da.a]||!ok[da.b]) {
			da=q.top(); q.pop();
		}
		
		int a=da.a, b=da.b;
		ansx=da.x, ansy=da.y;
		
		if (r[b]==a) std::swap(a,b);
		if (a>b){
			ok[b]=false;
			r[a]=r[b];
			l[r[a]]=a;
			q.push(get(a,r[a]));
		} else {
			ok[a]=false;
			l[b]=l[a];
			r[l[b]]=b;
			q.push(get(b,l[b]));
		}
	}
	
	int g=gcd(ansx,ansy);
	ansx/=g; ansy/=g;
	if (ansx) printf("%d/%d\n",ansx,ansy); else printf("0\n");
}

int main(){
	int test; scanf("%d",&test);
	while (test--) solve();
}
\end{lstlisting}

\subsection{pq的妙用2}
\begin{lstlisting}
#include <bits/stdc++.h>
#define forto(i,a,b) for(int i=(a);i<=(b);i++)
typedef double D;
const D eps=1e-8;

const int N=200200;

struct data { D x; int k; D t; } a[N];

inline bool comp1(const data &a, const data &b){
	return a.x<b.x;
}

struct meet { int xx,yy; D t,x; };

inline bool operator< (const meet &a, const meet &b){
	return a.t>b.t;
}

bool get(data a, data b, D &t, D &x){
	if (a.t>b.t) std::swap(a,b);
	D va=100.0/a.k;
	D vb=100.0/b.k;
	a.x+=va*(b.t-a.t);
	a.t=b.t;
	if (a.x>b.x) { std::swap(a,b); std::swap(va,vb); }
	if (b.x-a.x<=eps){
		x=a.x;
		t=a.t;
		return true;
	}	
	if (a.k>=b.k) return false;
	t=(b.x-a.x)/(va-vb);
	x=a.x+t*va;
	t+=a.t;
	return true;
}

int l[N],r[N];
std::priority_queue<meet> q;

bool b[N];

int main(){
	int n; scanf("%d",&n);
	forto(i,1,n) scanf("%d%lf",&a[i].k,&a[i].x);
	std::sort(a+1,a+n+1,comp1);
	forto(i,2,n) l[i]=i-1;
	forto(i,2,n) r[i-1]=i;
	
	forto(i,2,n){
		D t,x;
		if (get(a[i-1],a[i],t,x)) q.push((meet){i-1,i,t,x});
	}
	
	while (!q.empty()){
		meet m=q.top(); q.pop();
		while (!q.empty() && (b[m.xx]||b[m.yy])) { m=q.top(); q.pop(); }
		if (b[m.xx]||b[m.yy]) break;
		
		int p1=m.xx, p2=m.yy;
		
		n++;
		a[n].x=m.x;
		a[n].k=a[p1].k+a[p2].k;
		a[n].t=m.t;
		
		if (r[p2]==p1) std::swap(p1,p2);
		l[n]=l[p1];
		r[l[n]]=n;
		
		r[n]=r[p2];
		l[r[n]]=n;
		
		b[p1]=b[p2]=true;
		
		D t,x;
		if (l[n] && get(a[n],a[l[n]],t,x)) q.push((meet){n,l[n],t,x});
		if (r[n] && get(a[n],a[r[n]],t,x)) q.push((meet){n,r[n],t,x});
	}
	
	int ans=0;
	forto(i,1,n) if (!b[i]) ans++;
	printf("%d\n",ans);
	forto(i,1,n) if (!b[i]) printf("%d ",a[i].k);
	return 0;
}
\end{lstlisting}

\end{document}