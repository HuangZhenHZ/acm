\documentclass{article}
\usepackage[UTF8]{ctex}

\usepackage{geometry}
\geometry{a4paper,scale=0.8}

\usepackage{fontspec}
\setmainfont{Consolas}

\usepackage{listings}
\lstset{language=c++,numbers=left,frame=single,tabsize=4,breaklines=true,basicstyle=\small}

\begin{document}

\title{HZ的临时acm模板}
\author{HZ}
\maketitle
\tableofcontents

\section{基本内容}

\subsection{代码开头}
\begin{lstlisting}
#include <bits/stdc++.h>
#define forto(i,a,b) for(int i=(a);i<=(b);i++)
#define fordown(i,a,b) for(int i=(a);i>=(b);i--)
#define forE(i,x) for(int i=la[x]; i; i=e[i].ne)
#define forv(i,v) for(size_t i=0; i<(v).size(); ++i)
int &cmin(int &x, int y) { return x>y?x=y:x; }
int &cmax(int &x, int y) { return x<y?x=y:x; }
#define IL inline
#define OP operator
typedef long long LL;
typedef double D;
const D pi=acos(-1), eps=1e-8;
int dcmp(D x) { return x>-eps ? x>eps : -1; }
int dcmp(D x, D y) { return dcmp(x-y); }
// relative error : (x-y)/max(1,max(x,y))
using namespace std;
\end{lstlisting}

\subsection{快速输入输出}
\begin{lstlisting}
// Fast getchar
char B[1<<20],*S=B,*T=B;
#define getchar() (S==T&&(T=(S=B)+fread(B,1,1<<20,stdin),S==T)?0:*S++)

// Fast putchar
char U[1<<20],*O=U,*W=U+(1<<20);
#define putchar(c) (O==W?fwrite(U,1,1<<20,stdout),O=U,1:1,*O++=(c))
#define clr_buf() (fwrite(U,1,O-U,stdout),O=U)
// remember to clr_buf() before return 0 in the end

// Fast Input
#define isd(c) ((c)>='0'&&(c)<='9')
IL char read(int &x){
	static char c; static bool f;
	x=0; c=getchar(); f=false;
	while (!isd(c) && c!='-') c=getchar();
	if (c=='-') { f=true; c=getchar(); }
	while (isd(c)) { x=x*10+c-'0'; c=getchar(); }
	if (f) x=-x;
	return c;
}

IL char read(D &x){
	static char c; static bool f;
	x=0; c=getchar(); f=false;
	while (!isd(c) && c!='-' && c!='.') c=getchar();
	if (c=='-') { f=true; c=getchar(); }
	while (isd(c)) { x=x*10+c-'0'; c=getchar(); }
	if (c=='.') {
		static D t; t=1; c=getchar();
		while (isd(c)) { x+=(t/=10)*(c-'0'); c=getchar(); }
	}
	if (f) x=-x;
	return c;
}

IL void read(char s[]){
	s++; *s=getchar();
	while (*s==' '||*s=='\n') *s=getchar();
	while (*s!=' '&&*s!='\n') *++s=getchar();
	*s=0;
}

// Fast Output
IL void write(int x){
	if (x<0) { putchar('-'); x=-x; }
	if (!x) { putchar('0'); return; }
	static char c[20]; static int top; top=0;
	while (x) { c[++top]='0'+x%10; x/=10; }
	while (top) putchar(c[top--]);
}

IL void write(D x){
	static LL t; t=int(x*1e6+(x>=0?0.5:-0.5));
	if (t<0) { putchar('-'); t=-t; }
	static char c[20]; static int top; top=0;
	while (t) { c[++top]='0'+t%10; t/=10; }
	while (top<=6) c[++top]='0';
	while (top>6) putchar(c[top--]);
	putchar('.');
	while (top) putchar(c[top--]);
}

IL void write(char s[]){
	s++; while (*s) putchar(*s++);
}
\end{lstlisting}

\subsection{STL}
\begin{lstlisting}
// 离散化
int n; scanf("%d",&n);
forto(i,1,n) scanf("%d",&a[i]);
forto(i,1,n) t[i]=a[i];
sort(t+1,t+n+1);
int m=unique(t+1,t+n+1)-(t+1);
forto(i,1,n) a[i]=lower_bound(t+1,t+1+m,a[i])-t;

// next_permutation
forto(i,1,n) a[i]=i;
do {
	forto(i,1,n) printf("%d ",a[i]);
	putchar('\n');
} while (next_permutation(a+1,a+n+1));
// prev_permutation

// multiset    multimap    iterator

// insert
map<int,int> a,b;
a.insert(b.begin(),b.end());

set<int> s;
int t[N];
s.insert(t+1,t+n+1);
\end{lstlisting}


\section{数学基础}

\subsection{快速幂}
\begin{lstlisting}
IL int pow(int a, LL b, int n){  //a^b mod n
	static int p; p=1;
	for(;b;b>>=1,a=LL(a)*a%n)
		if (b&1) p=LL(p)*a%n;
    return p;
}
\end{lstlisting}

\subsection{同余相关}
\begin{lstlisting}
IL LL gcd(LL a, LL b){
	static LL c;
	while (b) { c=a%b; a=b; b=c; }
	return a;
}

IL LL lcm(LL a, LL b) { return a/gcd(a,b)*b; }

void gcd(LL a, LL b, LL &d, LL &x, LL &y){
	if (!b){ d=a; x=1; y=0; return; }
	gcd(b,a%b,d,y,x); y-=x*(a/b);
}

IL void sim(LL &a, LL n){ a%=n; if (a<0) a+=n; }

IL LL solve(LL a, LL b, LL n){  // a*x==b (mod n)
	sim(a,n); sim(b,n);  // optional
	static LL d,x,y;
	gcd(a,n,d,x,y);
	if (b%d) return -1;
	b/=d; n/=d;
	if (x<0) x+=n;
	return b*x%n;
}

// x==a1 (mod n1); x==a2 (mod n2);
void merge(LL a1, LL n1, LL a2, LL n2, LL &x, LL &n){
	n=n1/gcd(n1,n2)*n2;
	LL k=solve(n1,a2-a1,n2);	
	if (k==-1){ x=-1; return; }
	sim(x=n1*k+a1,n);
}

// getinv , gcd(a,n) must be 1
IL LL getinv(LL a, LL n){
	static LL d,x,y;
	gcd(a,n,d,x,y);
	// if (d!=1) return -1;
	return x<0?x+n:x;
}
\end{lstlisting}

\subsection{线性筛法}
\begin{lstlisting}
const int N=100000;
bool b[N+10];
int a[N+10],cnt,mx[N+10],phi[N+10],mu[N+10];

void getprime(){
	forto(i,2,N) b[i]=true;
	mu[1]=1;
	forto(i,2,N){
		if (b[i]){
			a[++cnt]=i;
			mx[i]=cnt; phi[i]=i-1; mu[i]=-1;
		}
		for(int j=1; j<=mx[i]&&i*a[j]<=N; j++){
			int k=i*a[j];
			b[k]=false; mx[k]=j;
			phi[k]= j==mx[i] ? phi[i]*a[j] : phi[i]*(a[j]-1);
			mu[k]= j==mx[i] ? 0 : -mu[i];
		}
	}
}
\end{lstlisting}

\subsection{离散对数}
\begin{lstlisting}
// BSGS , a^x==b (mod n) , n is a prime
LL bsgs(LL a, LL b, LL n){
	LL m=(int)sqrt(n+0.5);
	LL p=pow(a,m,n); LL v=getinv(p,n);
	static hash_map x;
	x.clear();
	LL e=1; x[e]=0;
	for(LL i=1;i<=m;i++){
		e=e*a%n;
		if (!x.count(e)) x[e]=i;
	}
	for(LL i=0;i<n;i+=m){
		if (x.count(b)) return i+x[b];
		b=b*v%n;
	}
	return -1;
}
\end{lstlisting}

\subsection{hzwer的bsgs}
\begin{lstlisting}
//BSGS
//y^x==z (mod p) ->x=?
scanf("%d%d%d",&y,&z,&p),y%=p,z%=p;j=z;
if(y==0){puts("Cannot find x");continue;}
for(k=s=1;k*k<=p;k++);
std::map<int,int>hash;flag=0;
for(int i=0;i<k;i++,s=1LL*s*y%p,j=1LL*j*y%p)hash[j]=i;
for(int i=1,j=s;i<=k&&!flag;i++,j=1LL*j*s%p)
if(hash.count(j))ans=i*k-hash[j],flag=1;
if(flag==0)puts("Cannot find x");
else printf("%d\n",ans);

//exBSGS
int bsgs(int a,ll b,int p){
    if(a%=p,b%=p,b==1)return 0;
    ll t=1;int f,g,delta=0,m=sqrt(p)+1,i;
    for(g=gcd(a,p);g!=1;g=gcd(a,p)){
        if(b%g)return -1;
        b/=g,p/=g,t=t*(a/g)%p,delta++;
        if(b==t)return delta;
    }
    std::map<int,int>hash;
    for(i=0;i<m;i++,b=b*a%p)hash[b]=i;
    for(i=1,f=power(a,m);i<=m+1;i++)
    if(t=t*f%p,hash.count(t))return i*m-hash[t]+delta;
    return -1;
}
\end{lstlisting}

\subsection{Lucas}
\begin{lstlisting}
void init_Lucas(){
	fac[0]=1; forto(i,1,MOD-1) fac[i]=fac[i-1]*i%MOD;
	inv[1]=1; forto(i,2,MOD-1) inv[i]=(MOD-MOD/i)*inv[MOD%i]%MOD;
	inv[0]=1; forto(i,1,MOD-1) inv[i]=inv[i-1]*inv[i]%MOD;
}

IL LL C(int n, int m){
	LL ans=1;
	while (n||m){
		int a=n%MOD, b=m%MOD;
		n/=MOD; m/=MOD;
		if (a<b) return 0;
		ans= ans *fac[a]%MOD *inv[b]%MOD *inv[a-b]%MOD;
	}
	return ans;
}
\end{lstlisting}

\subsection{分数类}
\begin{lstlisting}
#define RR const R &

struct R{
	LL x,y;

	IL void sim(){ 
		if (y<0) { x=-x; y=-y; }
		LL d=gcd(ABS(x),y);
		x/=d; y/=d;
	}

	IL void pri() const {
		printf("%lld",x);
		if (y>1) printf("/%lld",y);
	}
};

IL R OP+ (RR a, RR b){
	R c=(R){a.x*b.y + b.x*a.y, a.y*b.y};
	c.sim(); return c;
}

IL R OP- (RR a, RR b){
	R c=(R){a.x*b.y - b.x*a.y, a.y*b.y};
	c.sim(); return c;
}

IL R OP* (RR a, RR b){
	R c=(R){a.x*b.x, a.y*b.y};
	c.sim(); return c;
}

IL R OP/ (RR a, RR b){
	R c=(R){a.x*b.y, a.y*b.x};
	c.sim(); return c;
}
\end{lstlisting}

\subsection{高斯消元}
\begin{lstlisting}
const int N=1000;
int n,m;
R a[N][N];

void solve(){
	scanf("%d%d",&n,&m);
	
	forto(i,1,n) forto(j,1,m){
		scanf("%lld",&a[i][j].x);
		a[i][j].y=1;
	}
	 
	int i=1, j=1;
	while (i<=n && j<=m){
		int k=i;
		while (k<=n && a[k][j].x==0) k++;
		if (k>n) { j++; continue; }
		if (k!=i) forto(t,j,m) std::swap(a[i][t],a[k][t]);
		
		forto(p,j+1,m) a[i][p]=a[i][p]/a[i][j];
		a[i][j]=(R){1,1};
		
		forto(t,1,n) if (t!=i && a[t][j].x){
			forto(p,j+1,m) a[t][p]=a[t][p]-a[i][p]*a[t][j];
			a[t][j]=(R){0,1};
		}
		i++; j++;
	}
	
	putchar('\n');
	forto(i,1,n) forto(j,1,m){
		a[i][j].pri();
		putchar(j==m?'\n':' ');
	}
	putchar('\n');
}
\end{lstlisting}

\subsection{xor方程组}
\begin{lstlisting}
#include <bits/stdc++.h>
#define forto(i,a,b) for(int i=(a);i<=(b);i++)
using namespace std;

const int N=1550;

int n,m;
bitset<N> a[N];

bool solve(){
	int i=1, j=1;
	
	while (i<=n && j<=m){
		int k=i;
		while (k<=n && !a[k][j]) k++;
		if (k>n) { j++; continue; }
		if (k!=i) swap(a[i],a[k]);
		
		if (j==m) return false;
		forto(t,1,n) if (t!=i && a[t][j]) a[t]^=a[i];
		i++; j++;
	}
	return true;
}

int main(){
	scanf("%d%d",&n,&m);
	forto(i,1,n){
		forto(j,1,m){
			int x; scanf("%d",&x);
			a[j][i]=x&1;
		}
		a[m+1][i]=1;
	}
	swap(n,m);
	a[++n][++m]=1;
	
	printf(!solve()?"Yes\n":"No\n");
	return 0;
}
\end{lstlisting}

\subsection{矩阵快速幂}
\begin{lstlisting}
struct mat { int n,m,x[N][N]; };

mat operator* (const mat &a, const mat &b){
	mat c; c.n=a.n; c.m=b.m;
	forto(i,1,c.n) forto(j,1,c.m){
		LL sum=0;
		forto(k,1,a.m) sum=(sum+LL(a.x[i][k])*LL(b.x[k][j]))%MOD;
		c.x[i][j]=sum%MOD;
	}
	return c;
}

mat iden(int n){
	mat a; a.n=a.m=n;
	forto(i,1,n) forto(j,1,n) a.x[i][j]=0;
	forto(i,1,n) a.x[i][i]=1;
	return a;
}
\end{lstlisting}

\subsection{数论前缀和}
\begin{lstlisting}
LL sdx(LL n){
	LL s=0, i=1;
	while (i<=n){
		LL j=n/(n/i);
		s+=(j-i+1)*(n/i);
		i=j+1;
	}
	return s;
}
LL ssx(LL n){
	LL s=0, i=1;
	while (i<=n){
		LL j=n/(n/i);
		s += (i+j)*(j-i+1)/2 * (n/i);
		i=j+1;
	}
	return s;
}
\end{lstlisting}

\subsection{瀚之的莫比乌斯}
\begin{lstlisting}
void getprime(int n){
	miu[1]=pre[1]=b[1]=1;
	for(int i=2;i<=n;i++){
		if(!b[i]) p[mx[i]=++cnt]=i, miu[i]=-1;
		for(int j=1;j<=mx[i];j++){
			int k=i*p[j]; if(k>n) break;
			b[k]=1; mx[k]=j;
			if(j==mx[i]) miu[k]=0;
				else miu[k]=miu[i]*miu[p[j]];
		}
		pre[i]=pre[i-1]+i*miu[i];
	}
}
ll f(int n,int m){return 1ll*n*m*(n+m+2)/2;} 
ll calc(int n,int m){ // sigma{ i+j | i<=n,j<=m,gcd(i,j)==1 }
	if(n>m) swap(n,m); ll ans=0;
	for(int i=1,j=0,k=0;i<=n;i=min(j,k)+1)
		ans+=(pre[min(j=n/(n/i),k=m/(m/i))]-pre[i-1])*f(n/i,m/i);
	return ans;
}
\end{lstlisting}

\subsection{FFT}
\begin{lstlisting}
struct P{ double x,y; };
P operator+ (const P &a, const P &b) { return (P){a.x+b.x, a.y+b.y}; }
P operator- (const P &a, const P &b) { return (P){a.x-b.x, a.y-b.y}; }
P operator* (const P &a, const P &b) { return (P){a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x}; }

P w1[N],w2[N];
int rev[N];

void initfft(int n){
	int k=0, nn=n>>1;
	while (nn){ nn>>=1; k++; }
	double t=pi*2/n;
	forto(i,0,n-1){
		rev[i]=(rev[i>>1]>>1)+((i&1)<<(k-1));
		w1[i]=w2[(n-i)%n]=(P){cos(t*i),sin(t*i)};
	}
}

void fft(int n, P a[], P w[]){
	forto(i,0,n-1) if (i<rev[i]) { P t=a[i]; a[i]=a[rev[i]]; a[rev[i]]=t; }
	for(int k=1;k<n;k<<=1)
	for(int i=0;i<n;i+=k<<1)
	for(int j=0;j<k;j++){
		P t1=a[i+j], t2=a[i+j+k]*w[n/(k<<1)*j];
		a[i+j]=t1+t2; a[i+j+k]=t1-t2;
	}
}

int s1[N],s2[N];
P a1[N],a2[N];

int main(){
	int n1,n2; scanf("%d%d",&n1,&n2);
	forto(i,0,n1) scanf("%d",&s1[i]);
	forto(i,0,n2) scanf("%d",&s2[i]);
	forto(i,0,n1) a1[i]=(P){double(s1[i]),0};
	forto(i,0,n2) a2[i]=(P){double(s2[i]),0};
	int n=1;
	while (n<=n1+n2) n<<=1;
	initfft(n);
	fft(n,a1,w1);
	fft(n,a2,w1);
	forto(i,0,n-1) a1[i]=a1[i]*a2[i];
	fft(n,a1,w2);
	forto(i,0,n1+n2) printf("%d ",int(round(a1[i].x/n)));
	return 0;
}
\end{lstlisting}

\subsection{hzwer的FFT和NTT}
\begin{lstlisting}
//FFT
for(k=1;k<n<<1;k<<=1,L++);L--;
for(i=1;i<k;i++)rev[i]=(rev[i>>1]>>1)|((i&1)<<L);
for(i=0;i<=k;i++)w[1][k-i]=w[0][i]=(P){cos(PI*2*i/k),sin(PI*2*i/k)};

void FFT(P*a,int n,P*w){
	int i,j,k;
	for(i=1;i<n;i++)if(i>rev[i])std::swap(a[i],a[rev[i]]);
	for(i=2;i<=n;i<<=1)
	for(j=0;j<n;j+=i)
	for(k=0;k<i>>1;k++)
	tmp=a[j+k+i/2]*w[n/i*k],a[j+k+i/2]=a[j+k]-tmp,a[j+k]=a[j+k]+tmp;
}


//NTT
#define ck(x) (x>=p?x-=p:1)
for(n=1;n<m;n<<=1,l++);n<<=1;g=power(3,(P-1)/n);
for(w[0][0]=w[1][0]=i=1;i<n;i++){
	w[1][n-i]=w[0][i]=g*w[0][i-1]%P;
	rev[i]=(rev[i>>1]>>1)|((i&1)<<l);
}

void FFT(int*a,int*w){
	int i,j,k,tmp;
	for(i=0;i<n;i++)if(i>rev[i])tmp=a[i],a[i]=a[rev[i]],a[rev[i]]=tmp;
	for(i=2;i<=n;i<<=1)
	for(j=0;j<n;j+=i)
	for(k=0;k<i>>1;k++)
	tmp=1LL*a[j+k+i/2]*w[n/i*k]%p,a[j+k+i/2]=a[j+k]-tmp+p,a[j+k]+=tmp,ck(a[j+k+i/2]),ck(a[j+k]);
}
\end{lstlisting}

\subsection{FFT模任意质数}
\begin{lstlisting}
//luoguP4245 【模板】MTT
给定2个多项式F(x),G(x)，请求出F(x)*G(x)F(x)。
系数对p取模，且不保证p可以分解成p=a*2^k+1之形式。
输入格式：
输入共3行。
第一行3个整数n,m,p，分别表示F(x),G(x)的次数以及模数p。
第二行为n+1个整数，第i个整数a_i表示F(x)的i-1次项的系数。
第三行为m+1个整数，第i个整数b_i表示G(x)的i-1次项的系数。
输出格式：
输出n+m+1个整数，第i个整数c_i表示F(x)*G(x)的i-1次项的系数。

#include<cstdio>
#include<cmath>
#include<algorithm>
const int N = 262144 + 10, M = 32767;
const double pi = acos(-1.0);
typedef long long LL;
int read() {
	char ch = getchar(); int f = 1, x = 0;
	for(;ch < '0' || ch > '9'; ch = getchar()) if(ch == '-') f = -1;
	for(;ch >= '0' && ch <= '9'; ch = getchar()) x = (x << 1) + (x << 3) - '0' + ch;
	return x * f;
}
struct cp {
	double r, i;
	cp(double _r = 0, double _i = 0) : r(_r), i(_i) {}
	cp operator * (const cp &a) {return cp(r * a.r - i * a.i, r * a.i + i * a.r);}
	cp operator + (const cp &a) {return cp(r + a.r, i + a.i);}
	cp operator - (const cp &a) {return cp(r - a.r, i - a.i);}
}w[N], nw[N], da[N], db[N];
cp conj(cp a) {return cp(a.r, -a.i);}
int L, n, m, a[N], b[N], c[N], R[N], P;
void Pre() {
	int x = 0; for(L = 1; (L <<= 1) <= n + m; ++x) ;
	for(int i = 1;i < L; ++i) R[i] = (R[i >> 1] >> 1) | (i & 1) << x;
	for(int i = 0;i < L; ++i) w[i] = cp(cos(2 * pi * i / L), sin(2 * pi * i / L));
}
void FFT(cp *F) {
	for(int i = 0;i < L; ++i) if(i < R[i]) std::swap(F[i], F[R[i]]);
	for(int i = 2, d = L >> 1;i <= L; i <<= 1, d >>= 1) 
	for(int j = 0;j < L; j += i) {
		cp *l = F + j, *r = F + j + (i >> 1), *p = w, tp;
		for(int k = 0;k < (i >> 1); ++k, ++l, ++r, p += d) 
		tp = *r * *p, *r = *l - tp, *l = *l + tp;
	}
}
void Mul(int *A, int *B, int *C) {
	for(int i = 0;i < L; ++i) (A[i] += P) %= P, (B[i] += P) %= P;
	static cp a[N], b[N], Da[N], Db[N], Dc[N], Dd[N];
	for(int i = 0;i < L; ++i) a[i] = cp(A[i] & M, A[i] >> 15);
	for(int i = 0;i < L; ++i) b[i] = cp(B[i] & M, B[i] >> 15);
	FFT(a); FFT(b);
	for(int i = 0;i < L; ++i) {
		int j = (L - i) & (L - 1); static cp da, db, dc, dd;
		da = (a[i] + conj(a[j])) * cp(0.5, 0);
		db = (a[i] - conj(a[j])) * cp(0, -0.5);
		dc = (b[i] + conj(b[j])) * cp(0.5, 0);
		dd = (b[i] - conj(b[j])) * cp(0, -0.5);
		Da[j] = da * dc; Db[j] = da * dd; Dc[j] = db * dc; Dd[j] = db * dd; //顺便区间反转，方便等会直接用DFT代替IDFT 
	}
	for(int i = 0;i < L; ++i) a[i] = Da[i] + Db[i] * cp(0, 1);
	for(int i = 0;i < L; ++i) b[i] = Dc[i] + Dd[i] * cp(0, 1);
	FFT(a); FFT(b);
	for(int i = 0;i < L; ++i) {
		int da = (LL) (a[i].r / L + 0.5) % P; //直接取实部和虚部 
		int db = (LL) (a[i].i / L + 0.5) % P;
		int dc = (LL) (b[i].r / L + 0.5) % P;
		int dd = (LL) (b[i].i / L + 0.5) % P;
		C[i] = (da + ((LL)(db + dc) << 15) + ((LL)dd << 30)) % P; 
	}
}
int main() {
	n = read(); m = read(); P = read();
	for(int i = 0;i <= n; ++i) a[i] = read();
	for(int j = 0;j <= m; ++j) b[j] = read();
	Pre(); Mul(a, b, c); 
	for(int i = 0;i <= n + m; ++i) printf("%d ", (c[i] + P) % P); puts("");
	return 0;
}


//三模数
#include<cstdio>
#include<algorithm>
#include<cstring>
#define getchar() (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1<<21, stdin), p1 == p2) ? EOF : *p1++)
#define swap(x,y) x ^= y, y ^= x, x ^= y
#define LL long long 
const int MAXN = 3 * 1e6 + 10;
using namespace std;
char buf[1<<21], *p1 = buf, *p2 = buf;
inline int read() { 
	char c = getchar(); int x = 0, f = 1;
	while(c < '0' || c > '9') {if(c == '-') f = -1; c = getchar();}
	while(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();
	return x * f;
}
const int P1 = 469762049, P2 = 998244353, P3 = 1004535809, g = 3; 
const LL PP = 1ll * P1 * P2;
int N, M, P, limit = 1, L;
int A[MAXN], B[MAXN], C[MAXN], D[MAXN], Ans[3][MAXN], r[MAXN];
LL fastmul(LL a, LL b, LL mod) {
	a %= mod, b %= mod;
	return ((a * b - (LL)((LL)((long double)a / mod * b + 1e-3) * mod)) % mod + mod) % mod;
}
int fastpow(int a, int p, int mod) {
	int base = 1;
	while(p) {
		if(p & 1) base = 1ll * a * base % mod;
		a = 1ll * a * a % mod; p >>= 1;
	}
	return base % mod;
} 
void NTT(int *A, const int n, const int type, const int mod) {
	for(int i = 0; i < n; i++)
		if(i < r[i]) swap(A[i], A[r[i]]);
	for(int mid = 1; mid < n; mid <<= 1) {
		int W = fastpow(type == 1 ? g : fastpow(g, mod - 2, mod) , (mod - 1) / (mid << 1), mod);
		for(int j = 0; j < n; j += (mid << 1)) {
			int w = 1;
			for(int k = 0; k <mid; k++, w = 1ll * w * W % mod) {
				int x = A[j + k], y = 1ll * w * A[j + k + mid] % mod;
				A[j + k] = (x + y) % mod,
				A[j + k + mid] = (x - y + mod) % mod;
			}
		}
	}
	if(type == -1) {
		int inv = fastpow(n, mod - 2, mod);
		for(int i = 0; i < n; i++) 
			A[i] = 1ll * A[i] * inv % mod;
	}
}
int main() {
	#ifdef WIN32
	freopen("a.in", "r", stdin);
	#endif
	N = read(), M = read(), P = read();
	for(int i = 0; i <= N; i++) A[i] = read();
	for(int i = 0; i <= M; i++) B[i] = read();
	
	while(limit <= N + M) limit <<= 1, L++;
	for(int i = 0; i <= limit; i++) r[i] = (r[i >> 1] >> 1) | ((i & 1) << (L - 1));
	
	copy(A, A + N + 1, C); copy(B, B + M + 1, D);
	NTT(C, limit, 1, P1); NTT(D, limit, 1, P1);
	for(int i = 0; i <= limit; i++) Ans[0][i] = 1ll * C[i] * D[i] % P1;
	
	memset(C, 0, sizeof(C)); memset(D, 0, sizeof(D));
	copy(A, A + N + 1, C); copy(B, B + M + 1, D);
	NTT(C, limit, 1, P2); NTT(D, limit, 1, P2);
	for(int i = 0; i <= limit; i++) Ans[1][i] = 1ll * C[i] * D[i] % P2;
	
	memset(C, 0, sizeof(C)); memset(D, 0, sizeof(D));
	copy(A, A + N + 1, C); copy(B, B + M + 1, D);
	NTT(C, limit, 1, P3); NTT(D, limit, 1, P3);
	for(int i = 0; i <= limit; i++) Ans[2][i] = 1ll * C[i] * D[i] % P3;
	
	NTT(Ans[0], limit, -1, P1);
	NTT(Ans[1], limit, -1, P2);
	NTT(Ans[2], limit, -1, P3);
	
	for(int i = 0; i <= N + M; i++) {
		LL A = (fastmul(1ll * Ans[0][i] * P2 % PP, fastpow(P2 % P1, P1 - 2, P1), PP) + 
				fastmul(1ll * Ans[1][i] * P1 % PP, fastpow(P1 % P2, P2 - 2, P2), PP) ) % PP;
		LL K = ((Ans[2][i] - A) % P3 + P3) % P3 * fastpow(PP % P3, P3 - 2, P3) % P3;
		printf("%lld ",(A % P + ((K % P) * (PP % P)) % P ) % P);		 
	}
	return 0;
}
\end{lstlisting}

\section{字符串}

\subsection{KMP}
\begin{lstlisting}
// next[1]=0; kmp(s+1, next+1, s, next);
void kmp(char s1[], int next1[], char s2[], int next2[]){
	for(int i=1,j=0; s1[i]; i++){
        while (j && s1[i]!=s2[j+1]) j=next2[j];
        if (s1[i]==s2[j+1]) j++;
        next1[i]=j;
    }
}
\end{lstlisting}

\subsection{扩展KMP}
\begin{lstlisting}
// extkmp(s+1, ext+1, s, ext);
void extkmp(char s1[], int ext1[], char s2[], int ext2[]){
	int len1=strlen(s1+1), len2=strlen(s2+1);
	int k=1, j=0;
	while (s1[j+1]==s2[j+1]&&j<len1) j++;
	ext1[1]=j;
	for (int i=2;i<=len1;i++){
		int len=ext2[i-k+1];
		if (i+len-1<j) ext1[i]=len;
		else {
			len=j-i+1;
			if (len<0) len=0;
			while (s1[i+len]==s2[len+1]&& len<len2) len++;
			ext1[i]=len;
			k=i; j=i+len-1;
		}
	}
}
\end{lstlisting}

\subsection{后缀数组}
\begin{lstlisting}
char s[N];
int n,sa[N],rk[N<<1],c[N],x[N],h[N];

void suffix_array(){
	forto(i,1,n){ sa[i]=i; rk[i]=s[i]; }
	for(int m=300,k=0; k<n; k?k<<=1:k++){
		forto(i,1,m) c[i]=0;
		forto(i,1,n) c[rk[i]]++;
		forto(i,2,m) c[i]+=c[i-1];
		int p=0;
		forto(i,n-k+1,n) x[++p]=i;
		forto(i,1,n) if (sa[i]>k) x[++p]=sa[i]-k;
		fordown(i,n,1) sa[c[rk[x[i]]]--]=x[i];
		m=1; x[sa[1]]=1;
		forto(i,2,n) x[sa[i]]= rk[sa[i]]==rk[sa[i-1]] && rk[sa[i]+k]==rk[sa[i-1]+k] ?m:++m;
		forto(i,1,n) rk[i]=x[i];
		if (m==n) break;
	}
	forto(i,1,n) if (rk[i]!=n){
		int j=sa[rk[i]+1];
		h[i]=h[i-1]?h[i-1]-1:0;
		while (s[i+h[i]]==s[j+h[i]]) h[i]++;
	}
}

// 补充内容
forto(i,1,n-1) hh[i]=h[sa[i]];

void init_rmq(){
	forto(i,1,n) f[0][i]=hh[i];
	for(int i=0,k=1; k+k<=n; i++,k<<=1)
		forto(j,1,n-k-k+1)
			f[i+1][j]=min(f[i][j],f[i][j+k]);
			
	forto(len,1,n){
		int i=0,k=1;
		while (k+k<len) i++, k<<=1;
		fi[len]=i; fk[len]=k;
	}
}
int get_rmq(int l, int r){
	int i=fi[r-l+1], k=fk[r-l+1];
	return min(f[i][l],f[i][r-k+1]);
}

int lca(int x, int y){
	if (x==y) return n-x+1;
	x=rk[x]; y=rk[y];
	if (x>y) swap(x,y);
	return get_rmq(x,y-1);
}

struct name {
	int l,r;
	int len() const { return r-l+1; }
	char operator[] (int p) const {
		return 1<=p && p<=len() ? s[l+p-1] : 0;
	}
	void pri(int mx=N) const {
		int rr=min(r,l+mx-1);
		forto(i,l,rr) putchar(s[i]);
		putchar('\n');
	}
} a[N];

int lca(const name &x, const name &y){
	return min(lca(x.l,y.l), min(x.len(),y.len()));
}

bool comp(const name &x, const name &y){
	int t=lca(x,y);
	return x[t+1]<y[t+1];
}
\end{lstlisting}

\subsection{manacher}
\begin{lstlisting}
char str[N],s[N<<1];
int f[N<<1];

void manacher(){
	int n=0;
	for(int i=0;str[i];i++){
		s[++n]='#';
		s[++n]=str[i];
	}
	s[++n]='#';

	int mx=1,mr=1;
	forto(i,2,n){
		int t=0;
		if (i<mr) t=MIN(f[2*mx-i],mr-i);
		while (i-t-1 && s[i-t-1]==s[i+t+1]) t++;
		f[i]=t;
		if (i+t>mr){ mx=i; mr=i+t; }
	}
}
\end{lstlisting}

\subsection{回文自动机}
\begin{lstlisting}
const int N=300000+100, alpha=26;
int n,s[N],num[N];
int p,last,next[N][alpha],fail[N],len[N],cnt[N];
void init(){
	s[n=0]=len[p=2]=-1;
	fail[fail[last=1]=2]=2;
}
int getfail(int x){
	while (s[n-len[x]-1]!=s[n]) x=fail[x];
	return x;
}
void add(int c){
	s[++n]=c;
	int cur=getfail(last);
	if (!next[cur][c]){
		len[++p]=len[cur]+2;
		fail[p]=next[getfail(fail[cur])][c];
		if (!fail[p]) fail[p]=1;
		next[cur][c]=p;
	}
	last=next[cur][c];
	cnt[last]++;
}
\end{lstlisting}

\subsection{后缀自动机}
\begin{lstlisting}
#include <bits/stdc++.h>
#define forto(i,a,b) for(int i=(a);i<=(b);i++)
#define fordown(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;

const int N=200200, alpha=26;

char s[N];
int S,cnt,last;
int a[N],fa[N],l[N],ch[N][alpha];

void add(int x){
	int c=a[x];
	int p=last,np=++cnt;last=np;
	l[np]=x;
	for(;p&&!ch[p][c];p=fa[p])ch[p][c]=np;
	if(!p)fa[np]=S;
	else {
		int q=ch[p][c];
		if(l[p]+1==l[q])fa[np]=q;
		else {
			int nq=++cnt;l[nq]=l[p]+1;
			memcpy(ch[nq],ch[q],sizeof ch[q]);
			fa[nq]=fa[q];
			fa[np]=fa[q]=nq;
			for(;ch[p][c]==q;p=fa[p])ch[p][c]=nq;
		}
	}
}

int sg[N];
bool vis[N];

int get(int x){
	if (vis[x]) return sg[x];
	bool a[30]={false};
	forto(i,0,alpha-1) if (ch[x][i]) a[get(ch[x][i])]=true;
	int i=0; while (a[i]) i++;
	vis[x]=true;
	return sg[x]=i;
}

int main(){
	while (scanf("%s",s+1)>0){
		S=cnt=last=0;
		last=S=++cnt;
		int len=strlen(s+1);
		forto(i,0,len*2){
			fa[i]=l[i]=0; vis[i]=false;
			memset(ch[i],0,sizeof(ch[i]));
		}
		forto(i,1,len) a[i]=s[i]-'a';
		forto(i,1,len) add(i);
		get(1);
		
		int ans=0;
		int m; scanf("%d",&m);
		while (m--){
			scanf("%s",s+1);
			int x=1;
			for(int i=1; s[i]; i++) x=ch[x][s[i]-'a'];
			ans^=sg[x];
		}
		printf(ans?"Alice\n":"Bob\n");
	}
	return 0;
}
\end{lstlisting}		


\section{图论}

\subsection{最短路}
\begin{lstlisting}
#include <bits/stdc++.h>
#define forto(i,a,b) for(int i=(a);i<=(b);i++)
using namespace std;
typedef long long LL;
#define F first
#define S second
typedef pair<LL,int> P;
#define MP make_pair

const int N=100100;
const LL inf=LL(0x7fffffff)*LL(0x7fffffff);

struct G {
	struct E { int to,ne; LL dis; } e[N];
	int n,m,la[N];
	
	void add(int x, int y, LL z){
		e[++m]=(E){y,la[x],z}; la[x]=m;
	}
	
	priority_queue < P,vector<P>,greater<P> > q;
	LL d[N],s[N];
	P a[N];
	
	void solve(int u){
		while (!q.empty()) q.pop();
		forto(i,1,n) d[i]=inf;
		d[u]=0; q.push(MP(0,u));
		
		while (!q.empty()){
			P p=q.top(); q.pop();
			while (!q.empty() && d[p.S]!=p.F){
				p=q.top(); q.pop();
			}
			if (d[p.S]!=p.F) break;
			int x=p.S;
			for(int i=la[x]; i; i=e[i].ne){
				int y=e[i].to;
				if (d[x]+e[i].dis < d[y]){
					d[y]=d[x]+e[i].dis;
					q.push(MP(d[y],y));
				}
			}
		}
		
		forto(i,1,n) s[i]=0;
		s[u]=1;
		forto(i,1,n) a[i]=MP(d[i],i);
		sort(a+1,a+n+1);
		forto(t,1,n){
			int x=a[t].S;
			if (d[x]==inf) break;
			for(int i=la[x]; i; i=e[i].ne){
				int y=e[i].to;
				if (d[x]+e[i].dis == d[y]) s[y]+=s[x];
			}
		}
	}
	
} g1,g2;

int xx[N],yy[N];
LL zz[N];

void getans(int x, int y, LL z){
	LL t1 = g1.d[x] + z + g2.d[y];
	if (g1.d[x]!=inf && g2.d[y]!=inf && t1 == g1.d[2]){
		if (g1.s[x]*g2.s[y]==g1.s[2]) printf("SAD\n");
			else printf("SOSO\n");
		return;
	}
	LL t2 = g1.d[y] + z + g2.d[x];
	if (g1.d[y]!=inf && g2.d[x]!=inf && t2 < g1.d[2]) printf("HAPPY\n");
		else printf("SOSO\n");
}

int main(){
	int n,m; scanf("%d%d",&n,&m);
	g1.n = g2.n = n;
	forto(i,1,m){
		int x,y; LL z; scanf("%d%d%lld",&x,&y,&z);
		g1.add(x,y,z); g2.add(y,x,z);
		xx[i]=x; yy[i]=y; zz[i]=z;
	}
	g1.solve(1); g2.solve(2);

	forto(i,1,m) getans(xx[i],yy[i],zz[i]);
	return 0;
}
\end{lstlisting}

\subsection{树的直径}
\begin{lstlisting}
int bfs(int x){
	q[l=r=1]=x;
	forto(i,1,n) dis[i]=-1;
	dis[x]=0;
	int ans=x;
	while (l<=r){
		x=q[l++];
		for(int i=la[x];i;i=e[i].ne){
			int y=e[i].to;
			if (dis[y]==-1){
				dis[y]=dis[x]+e[i].dis;
				if (dis[y]>dis[ans]) ans=y;
				q[++r]=y;
			}
		}
	}
	return ans;
}

int x=bfs(1);  int y=bfs(x);
\end{lstlisting}

\subsection{强连通分量}
\begin{lstlisting}
int dfn[N],low[N],time;
int scc[N],cnt;
int sta[N],top;
int size[N];

void dfs(int x){
    dfn[x]=low[x]=++time;
    sta[++top]=x;
    forE(i,x){
        int y=e[i].to;
        if (!scc[y]){
            if (!dfn[y]) dfs(y);
            if (low[y]<low[x]) low[x]=low[y];
        }
    }
    if (dfn[x]==low[x]){
        cnt++;
        while (!scc[x]){
            scc[sta[top--]]=cnt;
            size[cnt]++;
        }
    }
}

forto(i,1,n) if (!dfn[i]) dfs(i);
\end{lstlisting}

\subsection{割顶和桥}
\begin{lstlisting}
int dfn[N],low[N],cnt;
int sta[N],top;
int scc[N],scc_cnt;

void dfs(int x, int fa){
	dfn[x]=low[x]=++cnt; sta[++top]=x;
	for(int i=la[x];i;i=e[i].ne){
		int y=e[i].to;
		if (y!=fa){
			if (low[y]==0){
				dfs(y,x);
				low[x]=MIN(low[x],low[y]);
			} else low[x]=MIN(low[x],dfn[y]);
		}
	}
	if (dfn[x]==low[x]){
		scc_cnt++;
		while (sta[top]!=x) scc[sta[top--]]=scc_cnt;
		scc[sta[top--]]=scc_cnt;
	}	
}

dfs(1,0);
\end{lstlisting}

\subsection{网络流}
\begin{lstlisting}
int n,m,la[N],top,q[N],cur[N],dis[N];
struct E{int to,cap,next;} e[M*2];

void add(int a, int b, int c){
	e[++top]=(E){b,c,la[a]}; la[a]=top;
	e[++top]=(E){a,0,la[b]}; la[b]=top;
}
	// remember to set top=1

bool bfs(){
	forto(i,1,n) dis[i]=inf; dis[1]=0;
	int l=1, r=1; q[1]=1;
	while (l<=r){
		int t=q[l++];
		for(int i=la[t];i;i=e[i].next)
		if (e[i].cap && dis[e[i].to]==inf)
			dis[ q[++r]=e[i].to ]=dis[t]+1;
	}
	return dis[n]!=inf;
}

int dinic(int x, int a){
	if (x==n||a==0) return a;
	int flow=0;
	for(int &i=cur[x];i;i=e[i].next)
	if (dis[e[i].to]==dis[x]+1 && e[i].cap){
		int t=dinic(e[i].to,MIN(a,e[i].cap));
		flow+=t; a-=t;
		e[i].cap-=t; e[i^1].cap+=t;
		if (a==0) return flow;
	}
	return flow;
}

int maxflow(){
	int flow=0;
	while (bfs()){
		forto(i,1,n) cur[i]=la[i];
		flow+=dinic(1,inf);
	}
	return flow;
}
\end{lstlisting}

\subsection{费用流}
\begin{lstlisting}
struct E{ int to,cap,dis,ne; } e[M<<1];
int n,la[N],e_top;

void add(int x, int y, int cap, int dis){
	e[++e_top]=(E){y,cap,dis,la[x]}; la[x]=e_top;
	e[++e_top]=(E){x,0,-dis,la[y]}; la[y]=e_top;
}
int dis[N],q[N],l,r,prex[N],prei[N],low[N];
bool vis[N];

bool spfa(){
	forto(i,1,n){ dis[i]=inf; vis[i]=false; }
	dis[1]=0; vis[1]=true; low[1]=inf;
	q[l=r=1]=1;
	while (l<=r){
		int x=q[l++]; vis[x]=false;
		forE(i,x,y,z) if (e[i].cap && dis[x]+z<dis[y]){
			dis[y]=dis[x]+z;
			prex[y]=x; prei[y]=i; low[y]=MIN(low[x],e[i].cap);
			if (vis[y]==false) vis[q[++r]=y]=true;
		}
	}
	return dis[n]!=inf;
}
int flow,cost;

void mcmf(){
	while (spfa()){
		for(int x=n;x!=1;x=prex[x]){
			int i=prei[x];
			e[i].cap-=low[n];
			e[i^1].cap+=low[n];
		}
		flow+=low[n];
		cost+=low[n]*dis[n];
	}
}
\end{lstlisting}

\subsection{hzwer的网络流}
\begin{lstlisting}
// dinic

bool bfs()
{
	int head=0,tail=1;
	for(int i=0;i<=T;i++)h[i]=-1;
	q[0]=0;h[0]=0;
	while(head!=tail)
	{
		int now=q[head];head++;
		for(int i=last[now];i;i=e[i].next)
			if(e[i].v&&h[e[i].to]==-1)
			{
				h[e[i].to]=h[now]+1;
				q[tail++]=e[i].to;
			}
	}
	return h[T]!=-1;
}

int dfs(int x,int f)
{
	if(x==T)return f;
	int w,used=0;
	for(int i=cur[x];i;i=e[i].next)
		if(h[e[i].to]==h[x]+1)
		{
			w=f-used;
			w=dfs(e[i].to,min(w,e[i].v));
			e[i].v-=w;e[i^1].v+=w;
			if(e[i].v)cur[x]=i;
			used+=w;if(used==f)return f;
		}
	if(!used)h[x]=-1;
	return used;
}

void dinic()
{
	while(bfs())
	{
		for(int i=0;i<=T;i++)
			cur[i]=last[i];
		ans+=dfs(0,inf);
	}
} 

// spfa

bool spfa()
{
	for(int i=0;i<=T;i++)dis[i]=inf;
	int head=0,tail=1;
	dis[0]=0;q[0]=0;inq[0]=1;
	while(head!=tail)
	{
		int now=q[head++];if(head==1601)head=0;
		for(int i=last[now];i;i=e[i].next)
			if(e[i].v&&e[i].c+dis[now]<dis[e[i].to])
			{
				dis[e[i].to]=e[i].c+dis[now];
				from[e[i].to]=i;
				if(!inq[e[i].to])
				{
					inq[e[i].to]=1;
					if(dis[e[i].to]<dis[q[head]])
					{
						head--;if(head==-1)head=1600;
						q[head]=e[i].to;
					}
					else
					{
						q[tail++]=e[i].to;
						if(tail==1601)tail=0;
					}
				}
			}
		inq[now]=0;
	}
	if(dis[T]==inf)return 0;
	return 1;
}

void mcf()
{
	int x=inf;
	for(int i=from[T];i;i=from[e[i].from])
		x=min(e[i].v,x);
	for(int i=from[T];i;i=from[e[i].from])
	{
		ans+=x*e[i].c;
		e[i].v-=x;e[i^1].v+=x;
	}
}

// zkw

bool spfa()
{
    memset(mark,0,sizeof(mark));
    for(int i=0;i<=T;i++)d[i]=-1;
    int head=0,tail=1;
    q[0]=T;mark[T]=1;d[T]=0;
    while(head!=tail)
    {
		int now=q[head];head++;if(head==605)head=0;
		for(int i=last[now];i;i=e[i].next)
			if(e[i^1].v&&d[now]+e[i^1].c>d[e[i].to])
			{
				d[e[i].to]=d[now]+e[i^1].c;
				if(!mark[e[i].to])
				{
					mark[e[i].to]=1;
					q[tail++]=e[i].to;
					if(tail==605)tail=0;
				}
			}
		mark[now]=0;
    }
    return d[0]!=-1;
}

int dfs(int x,int f)
{
    mark[x]=1;
    if(x==T)return f;
    int w,used=0;
    for(int i=last[x];i;i=e[i].next)
		if(d[e[i].to]==d[x]-e[i].c&&e[i].v&&!mark[e[i].to])
		{
			w=f-used;
			w=dfs(e[i].to,min(w,e[i].v));
			ans+=w*e[i].c;
			e[i].v-=w;e[i^1].v+=w;
			used+=w;if(used==f)return f;
		}
    return used;
}

void zkw()
{
    while(spfa())
    {
		mark[T]=1;
		while(mark[T])
		{
			memset(mark,0,sizeof(mark));
			dfs(0,inf);
		}
    }
}
\end{lstlisting}

\subsection{欧拉回路}
\begin{lstlisting}
#include<cstdlib>
#include<cstdio>

#define forto(i,a,b) for(int i=(a);i<=(b);i++)
#define fordown(i,a,b) for(int i=(a);i>=(b);i--)
#define forE(i,x) for(int i=la[x];i;i=e[i].ne)

const int N=100100, M=200200;

struct E{ int to,ne; } e[M<<1];
int t,n,m,la[N],e_top;
int in[N],out[N];

void add(int x, int y){
	out[x]++; in[y]++;
	e[++e_top]=(E){y,la[x]}; la[x]=e_top;
}

int sta[M],top;
bool vis[M<<1];

void dfs(int x){
	for(int i=la[x];i;i=la[x]){
		la[x]=e[i].ne;
		if (!vis[i]){
			if (t==1) vis[i]=vis[i^1]=true; else vis[i]=true;
			la[x]=e[i].ne;
		
			dfs(e[i].to);
		
			if (t==1) sta[++top]=(i&1)?(-(i>>1)):(i>>1);
				else sta[++top]=i;
		}
	}
}

int main(){
	scanf("%d",&t);
	scanf("%d%d",&n,&m);
	if (m==0){
		printf("YES");
		return 0;
	}
	
	if (t==1) e_top=1;
	forto(i,1,m){
		int x,y; scanf("%d%d",&x,&y);
		if (t==1){ add(x,y); add(y,x); }
		if (t==2) add(x,y);
	}
	
	if (t==1)
	forto(i,1,n) if (in[i]&1){
		printf("NO");
		return 0;
	}
	
	if (t==2)
	forto(i,1,n) if (in[i]!=out[i]){
		printf("NO");
		return 0;
	}
	
	if (t==1) dfs(e[2].to); else dfs(e[1].to);
	
	if (top!=m){
		printf("NO");
		return 0;
	}
	
	printf("YES\n");
	fordown(i,top,1) printf("%d ",sta[i]);
	return 0;
}
\end{lstlisting}

\subsection{带花树}
\begin{lstlisting}
#include<cstdlib>
#include<cstdio>

#define forto(i,a,b) for(int i=(a);i<=(b);i++)
#define fordown(i,a,b) for(int i=(a);i>=(b);i--)
#define forE(i,x) for(int i=la[x];i;i=e[i].ne)
#define add(x,y) { e[++e_top]=(E){y,la[x]}; la[x]=e_top; }

const int N=550;

struct E{ int to,ne; } e[N*N];
int n,m,la[N],e_top;

int f[N];
int find(int x){ return f[x]==x?x:f[x]=find(f[x]); }

int mat[N],pre[N],cond[N],q[N],l,r;

int vis[N],vt;
int lca(int x, int y){
	vt++; x=find(x); y=find(y);
	while (vis[x]!=vt){
		if (x){ vis[x]=vt; x=find(pre[mat[x]]); }
		int z=x; x=y; y=z;
	}
	return x;
}

void blossom(int x, int y, int g){
	while (find(x)!=g){
		pre[x]=y;
		if (cond[mat[x]]==1) cond[q[++r]=mat[x]]=0;
		if (f[x]==x) f[x]=g;
		if (f[mat[x]]==mat[x]) f[mat[x]]=g;
		y=mat[x]; x=pre[y];
	}
}

int match(int s){
	forto(i,1,n){ cond[i]=-1; pre[i]=0; f[i]=i; }
	cond[q[l=r=1]=s]=0;
	while (l<=r){
		int x=q[l++];
		forE(i,x){
			int y=e[i].to;
			if (cond[y]==-1){
				if (mat[y]==0){
					while (x){
						int t=mat[x];
						mat[x]=y; mat[y]=x;
						y=t; x=pre[y];
					}
					return true;
				}
				cond[y]=1; pre[y]=x;
				cond[q[++r]=mat[y]]=0;
			} else if (find(x)!=find(y) && cond[y]==0){
				int g=lca(x,y); blossom(x,y,g); blossom(y,x,g);
			}
		}
	}
	return false;
}

int main(){
	scanf("%d%d",&n,&m);
	int ans=0;
	while (m--){
		int x,y; scanf("%d%d",&x,&y);
		add(x,y); add(y,x);
	}
	forto(i,1,n) if (!mat[i]&&match(i)) ans++;
	printf("%d\n",ans);
	forto(i,1,n) printf("%d ",mat[i]);
	return 0;
}
\end{lstlisting}

\subsection{KM}
\begin{lstlisting}
#include<cstdlib>
#include<cstdio>

#define forto(i,a,b) for(int i=(a);i<=(b);i++)
#define fordown(i,a,b) for(int i=(a);i>=(b);i--)

#define MIN(a,b) ((a)<(b)?(a):(b))
#define MAX(a,b) ((a)>(b)?(a):(b))
#define cmin(a,b) ((b)<(a)?(a)=(b):(a))
#define cmax(a,b) ((b)>(a)?(a)=(b):(a))

typedef long long LL;
const int N=500, inf=0x7fffffff;

int n,fx[N],fy[N],pre[N];
LL w[N][N],lx[N],ly[N],sla[N];
bool vx[N],vy[N],a[N][N];
int q[N],l,r;

bool check(int x, int y){
	if (!fy[y]){
		while (x){
			int t=fx[x];
			fx[x]=y; fy[y]=x;
			y=t; x=pre[y];
		}
		return true;
	}
	vy[y]=true; pre[y]=x;
	vx[q[++r]=fy[y]]=true;
	return false;
}

void bfs(int s){
	forto(i,1,n){ vx[i]=vy[i]=false; sla[i]=inf; }
	vx[q[l=r=1]=s]=true;
	while (true){
		while (l<=r){
			int x=q[l++];
			forto(y,1,n) if (!vy[y]){
				LL t=lx[x]+ly[y]-w[x][y];
				if (t==0 && check(x,y)) return;
				if (t && t<sla[y]){ sla[y]=t; pre[y]=x; }
			}
		}
		int d=inf;
		forto(y,1,n) if (!vy[y]) cmin(d,sla[y]);
		forto(x,1,n) if (vx[x]) lx[x]-=d;
		forto(y,1,n) if (vy[y]) ly[y]+=d; else sla[y]-=d;
		forto(y,1,n) if (!vy[y] && !sla[y] && check(pre[y],y)) return;
	}
}

void KM(){
	forto(x,1,n){
		lx[x]=w[x][1];
		forto(y,2,n) cmax(lx[x],w[x][y]);
	}
	forto(s,1,n) bfs(s);
}

int main(){
	int nl,nr,m;
	scanf("%d%d%d",&nl,&nr,&m);
	while (m--){
		int x,y,z; scanf("%d%d%d",&x,&y,&z);
		w[x][y]=z; a[x][y]=true;
	}
	n=MAX(nl,nr);
	
	KM();
	LL ans=0;
	forto(i,1,n) ans+=lx[i];
	forto(j,1,n) ans+=ly[j];
	printf("%lld\n",ans);
	forto(i,1,nl) if (a[i][fx[i]]) printf("%d ",fx[i]); else printf("0 ");
	return 0;
}
\end{lstlisting}

\subsection{最小树形图}
\begin{lstlisting}
#include<cstdlib>
#include<cstdio>
#include<cmath>

#define forto(i,a,b) for(int i=(a);i<=(b);i++)
#define fordown(i,a,b) for(int i=(a);i>=(b);i--)

#define MIN(a,b) ((a)<(b)?(a):(b))
#define MAX(a,b) ((a)>(b)?(a):(b))

const int N=110, M=40000, inf=0x7fffffff;
struct E{ int to,ne; double dis; } e[M];
int n,m,la[N],g[N],e_top;

void add1(int x, int y, double z){
	e[++e_top]=(E){y,g[x],z}; g[x]=e_top;
	e[++e_top]=(E){x,la[y],z}; la[y]=e_top;
}

void add2(int x, int y, double z){
	e[++e_top]=(E){y,la[x],z}; la[x]=e_top;
}

void build_graph(){
	static int x[N],y[N];
	forto(i,1,n) la[i]=g[i]=0;
	e_top=0;
	forto(i,1,n) scanf("%d%d",&x[i],&y[i]);
	forto(i,1,m){
		int a,b; scanf("%d%d",&a,&b);
		add1( a,b,sqrt( (x[a]-x[b])*(x[a]-x[b]) + (y[a]-y[b])*(y[a]-y[b]) ) );
	}
}

int q[N],l,r;
bool vis[N];

bool check(){
	forto(i,1,n) vis[i]=false;
	q[l=r=1]=1; vis[1]=true;
	while (l<=r){
		int x=q[l++];
		for(int i=g[x];i;i=e[i].ne){
			int y=e[i].to;
			if (vis[y]==false){
				vis[y]=true;
				q[++r]=y;
			}
		}
	}
	return r==n;
}

int f[N];

int find(int x){
	return f[x]==x?x:f[x]=find(f[x]);
}

bool ok[N];
int sta[N],top;
double cho[N];

double solve(){
	double ans=0;
	forto(i,1,n) f[i]=i;
	forto(i,1,n) ok[i]=vis[i]=false;
	ok[1]=true;
	
	forto(t,1,n){
		vis[sta[top=1]=find(t)]=true;
		while (ok[sta[top]]==false){
			int x=sta[top], y=0; double z=1e100;
			for(int i=la[x];i;i=e[i].ne)
			if (find(e[i].to)!=x && e[i].dis<z){
				z=e[i].dis;
				y=e[i].to;
			}
			
			y=find(y);
			
			cho[x]=z;
			ans+=z;
			
			if (vis[y]){
				for(int i=la[y];i;i=e[i].ne) e[i].dis-=cho[y];
				while (sta[top]!=y){
					vis[ x=sta[top--] ]=false;
					for(int i=la[x];i;i=e[i].ne) add2(y, e[i].to, e[i].dis-cho[x]);
					f[x]=y;
				}
			} else vis[sta[++top]=y]=true;
		}
		while (top){
			ok[sta[top]]=true;
			vis[sta[top--]]=false;
		}
	}
	return ans;
}
			
int main(){
	while (scanf("%d%d",&n,&m)>0){
		build_graph();	
		if (check()) printf("%.2f\n",solve()); else printf("poor snoopy\n");
	}
	return 0;
}
\end{lstlisting}

\subsection{最小树形图输出路径}
\begin{lstlisting}
using namespace std;  
  
const int INF=0x3f3f3f3f;  
const int maxn=2001000;  
  
int n,m;  
  
struct Edge  
{  
    int u,v,cost,id,ru,rv,rcost;  
}edge[maxn];  
  
void add_Edge(int id,int u,int v,int c)  
{  
    edge[id].id=id;  
    edge[id].u=edge[id].ru=u;  
    edge[id].v=edge[id].rv=v;  
    edge[id].cost=edge[id].rcost=c;  
}  
  
int pre[maxn],id[maxn],vis[maxn],in[maxn];  
  
//// !!!!  
int preid[maxn],useE[maxn];  
int eA[maxn],eD[maxn];  
int ex;  
  
int zhuliu(int root,int n,int m,Edge edge[])  
{  
    int ex=m,res=0;  
    while(true)  
    {  
        for(int i=0;i<n;i++) in[i]=INF;  
        for(int i=0;i<m;i++)  
        {  
            if(edge[i].u!=edge[i].v&&edge[i].cost<in[edge[i].v])  
            {  
                pre[edge[i].v]=edge[i].u;  
                in[edge[i].v]=edge[i].cost;  
  
                //// !!!!  
                preid[edge[i].v]=edge[i].id;  
            }  
        }  
        for(int i=0;i<n;i++)  
            if(i!=root&&in[i]==INF) return -1;  
        int tn=0;  
        memset(id,-1,sizeof(id));  
        memset(vis,-1,sizeof(vis));  
        in[root]=0;  
        for(int i=0;i<n;i++)  
        {  
            res+=in[i];  
            int v=i;  
            //// !!!!  
            if(i!=root) useE[preid[i]]++;  
            while(vis[v]!=i&&id[v]==-1&&v!=root)  
            {  
                vis[v]=i; v=pre[v];  
            }  
            if(v!=root&&id[v]==-1)  
            {  
                for(int u=pre[v];u!=v;u=pre[u]) id[u]=tn;  
                id[v]=tn++;  
            }  
        }  
        if(tn==0) break;  
        for(int i=0;i<n;i++)  
            if(id[i]==-1) id[i]=tn++;  
        for(int i=0;i<m;i++)  
        {  
            int v=edge[i].v;  
            edge[i].u=id[edge[i].u];  
            edge[i].v=id[edge[i].v];  
            if(edge[i].u!=edge[i].v)  
            {  
                edge[i].cost-=in[v];  
                //// !!!!  
                eA[ex]=edge[i].id;  
                eD[ex]=preid[v];  
                edge[i].id=ex;  
                ex++;  
            }  
        }  
        n=tn;  
        root=id[root];  
    }  
  
    //// !!!!  
    for(int i=ex-1;i>=m;i--)  
    {  
        if(useE[i])  
        {  
            useE[eA[i]]++; useE[eD[i]]--;  
        }  
    }  
  
    return res;  
}  
  
int main()  
{  
    freopen("input.txt","r",stdin);  
    freopen("output.txt","w",stdout);  
      
    scanf("%d%d",&n,&m);  
  
    for(int i=0,a,b,c;i<m;i++)  
    {  
        scanf("%d%d%d",&a,&b,&c);  
        a--; b--;  
        add_Edge(i,a,b,c);  
    }  
  
    int lens = zhuliu(0,n,m,edge);  
  
    if(lens==0||lens==-1) { printf("%d\n",lens); return 0; }  
  
    printf("%d\n",lens);  
    for(int i=0;i<m;i++)  
    {  
        if(useE[i]&&edge[i].rcost)  
            printf("%d ",i+1);  
    }  
    putchar(10);  
  
    return 0;  
}  
\end{lstlisting}

\subsection{2-SAT}
\begin{lstlisting}
#include<cstdio>
#include<vector>
#include<stack>
using namespace std;
const int maxn=600;

struct twosat{
	int n;
	vector<int> g[maxn*2];
	bool mark[maxn*2];
	stack<int> s;
	
	void add(int x,int xx,int y,int yy){
		x=x*2+xx;
		y=y*2+yy;
		g[x^1].push_back(y);
		g[y^1].push_back(x);
	}
	
	bool dfs(int x){
		if (mark[x^1]) return false;
		if (mark[x]) return true;
		mark[x]=true;
		s.push(x);
		for (int i=0; i<g[x].size(); i++)
			if (!dfs(g[x][i])) return false;
		return true;
	}
	
	bool solve(){
		for (int i=0;i<n*2;i+=2)
		if (!mark[i] && !mark[i+1]){
			while (!s.empty()) s.pop();
			if (!dfs(i)){
				while (!s.empty()){
					mark[s.top()]=false;
					s.pop();
				}
				if (!dfs(i+1)) return false;
			}
		}
		return true;
	}
} g;

int a[maxn],b[maxn];

int main(){
	int n,m;
	scanf("%d %d",&n,&m);
	for (int i=1;i<=m;i++){
		scanf("%d %d",&a[i],&b[i]);
		if (a[i]>b[i]){ int c=a[i]; a[i]=b[i]; b[i]=c; }
	}	
	g.n=m;	
	for (int i=1;i<=m;i++)
	for (int j=1;j<=m;j++)
	if ( a[i]<a[j] && a[j]<b[i] && b[i]<b[j] ){	
		g.add(i,0,j,0);
		g.add(i,1,j,1);
	}
	if (g.solve()) printf("panda is telling the truth..."); else printf("the evil panda is lying again");
	return 0;
}
\end{lstlisting}

\subsection{稳定婚姻问题}
\begin{lstlisting}
#include<cstdio>
#include<cctype>
#include<queue>
#include<cstring>
using namespace std;

char readchar(){
	int i=getchar();
	while (!isalpha(i)) i=getchar();
	return i;
}

const int maxn=50;

int list[maxn][maxn], order[maxn][maxn], next[maxn];
int a[maxn],b[maxn];
int na[200],nb[200],name[200];
queue<int> q;

void init(){
	memset(next,0,sizeof(next));
	memset(a,0,sizeof(a));
	memset(b,0,sizeof(b));
	memset(na,0,sizeof(na));
}	

void engage(int x,int y){
	int m=b[y];
	if (m){
		a[m]=0;
		q.push(m);
	}
	a[x]=y; b[y]=x;
}	

int main(){
	int t; scanf("%d",&t);
	while (t--){
		init();
		int n;
		scanf("%d",&n);
				
		for (int i=1;i<=n;i++){
			char j=readchar();
			na[j]=i;
		}
		for (int i=1;i<=n;i++){
			char j=readchar();
			nb[j]=i;
			name[i]=j;
		}
		for (int i=1;i<=n;i++){
			char c=readchar();
			for (int j=1;j<=n;j++){
				char d=readchar();
				list[na[c]][j]=nb[d];
			}
		}
		for (int i=1;i<=n;i++){
			char c=readchar();
			for (int j=1;j<=n;j++){
				char d=readchar();
				order[nb[c]][na[d]]=j;
			}
		}
		
		for (int i=1;i<=n;i++) q.push(i);
		
		while (!q.empty()){
			int i=q.front(); q.pop();
			int j=list[i][++next[i]];
			if (!b[j]) engage(i,j);
			else if(order[j][i]<order[j][b[j]]) engage(i,j);
			else q.push(i);
		}
		
		for (char i='A';i<='z';i++)
		if (na[i]){
			char j=name[a[na[i]]];
			printf("%c %c\n",i,j);
		}
		printf("\n");
	}
	return 0;
}
\end{lstlisting}

\subsection{hzwer的K短路}
\begin{lstlisting}
#include<ext/pb_ds/priority_queue.hpp>
#define pa pair<int,int>
#define inf 2000000000
using namespace std;
using namespace __gnu_pbds;
inline int read()
{
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
typedef __gnu_pbds::priority_queue<pa,greater<pa> > heap;
int n,m,K,cnt,cnt2;
int ans[105];
int d[10005],g[10005],tim[10005];
int last[10005],last2[10005];
heap q;
heap::point_iterator id[10005];
struct edge{int to,next,v;}e[10005],ed[10005];
void insert(int u,int v,int w)
{
	e[++cnt].to=v;e[cnt].next=last[u];last[u]=cnt;e[cnt].v=w;
	ed[++cnt2].to=u;ed[cnt].next=last2[v];last2[v]=cnt2;ed[cnt2].v=w;
}
void dijkstra()
{
	for(int i=1;i<=n;i++)d[i]=inf;
	d[1]=0;
	id[1]=q.push(make_pair(0,1));
	while(!q.empty())
	{
		int now=q.top().second;q.pop();
		for(int i=last2[now];i;i=ed[i].next)
			if(ed[i].v+d[now]<d[ed[i].to])
			{
				d[ed[i].to]=d[now]+ed[i].v;
				if(id[ed[i].to]!=0)
					q.modify(id[ed[i].to],make_pair(d[ed[i].to],ed[i].to));
				else id[ed[i].to]=q.push(make_pair(d[ed[i].to],ed[i].to));
			}
	}
}
void astar()
{
    if(d[n]==inf)return;
    q.push(make_pair(d[n],n));
	while(!q.empty())
	{
		int now=q.top().second,dis=q.top().first;q.pop();
		tim[now]++;
		if(now==1)ans[tim[now]]=dis;
		if(tim[now]<=K)
			for(int i=last[now];i;i=e[i].next)
				q.push(make_pair(dis-d[now]+d[e[i].to]+e[i].v,e[i].to));
	}
}
int main()
{
	n=read();m=read();K=read();
	for(int i=1;i<=m;i++)
	{
		int u=read(),v=read(),w=read();
		insert(u,v,w);
	}
	dijkstra();
	astar();
	for(int i=1;i<=K;i++)
		if(ans[i])printf("%d\n",ans[i]);
		else puts("-1");
	return 0;
}
\end{lstlisting}


\section{数据结构}

\subsection{哈希表}
\begin{lstlisting}
const int H=(1<<20)-1;
struct hash_map{
	int la[1<<20],top;
	struct E { LL key; int da,ne; } e[int(1e6)];
	IL void clear(){
		memset(la,0,sizeof(la)); top=0;
	}
	IL bool count(LL k){
		static int i; i=la[k&H];
		while (i&&e[i].key!=k) i=e[i].ne;
		return i;
	}
	IL int& OP[] (LL k){
		static int h,i; i=la[h=k&H];
		while (i&&e[i].key!=k) i=e[i].ne;
		if (!i){ e[i=++top]=(E){k,0,la[h]}; la[h]=top; }
		return e[i].da;
	}
};
\end{lstlisting}

\subsection{RMQ}
\begin{lstlisting}
inline void rmq(int n){
	for(int i=0,k=1; k<n; k<<=1,i++)
	forto(j,1,n-k) f[j][i+1]=MAX(f[j][i],f[j+k][i]);
}
inline int getrmq(int l, int r){
	int len=r-l+1, i=0, k=1;
	while (k<<1<=len){ k<<=1; i++; }
	return MAX(f[l][i],f[r-k+1][i]);
}
\end{lstlisting}

\subsection{树状数组}
\begin{lstlisting}
inline int sum(int x){
	int s=0;
	while (x>0){ s+=a[x]; x-=x&-x; }
	return s;
}
inline void add(int x, int d){
	while (x<=n){ a[x]+=d; x+=x&-x; }
}
\end{lstlisting}

\subsection{树链剖分}
\begin{lstlisting}
void find(int x, int father, int depth){
    size[x]=1; dep[x]=depth; son[x]=0; fa[x]=father;
    int maxsize=0;
    for (int i=0; i<g[x].size(); i++)
    if (g[x][i]!=father){
        int y=g[x][i];
        find(y,x,depth+1);
        size[x]+=size[y];
        if (size[y]>maxsize){
            maxsize=size[y];
            son[x]=y;
        }
    }
}

void connect(int x, int anc){
    tid[x]=++label; top[x]=anc;
    if (son[x]) connect(son[x], anc);
    for (int i=0; i<g[x].size(); i++){
        int y=g[x][i];
        if (y!=son[x] && y!=fa[x]) connect(y,y);
    }
}

int getsum(int x, int y){
    int sumnum=0;
    while (top[x]!=top[y]){
        if (dep[top[x]]<dep[top[y]]) { int z=x; x=y; y=z; }
        sumnum+=seq.getsum(tid[top[x]],tid[x]);
        x=fa[top[x]];
    }
    if (dep[x]<dep[y]) sumnum+=seq.getsum(tid[x],tid[y]);
        sumnum+=seq.getsum(tid[y],tid[x]);
    return sumnum;
}
\end{lstlisting}

\subsection{LCT}
\begin{lstlisting}
int n,fa[maxn],ch[maxn][2];
inline void ir(int x){ return ch[fa[x]][0]!=x && ch[fa[x]][1]!=x; }
inline void nt(int x){ return ch[fa[x]][1]==x; }
inline void ud(int x){ ... }
inline void pd(int x){ ... }

inline void rtt(int x){
	int y=fa[x], z=fa[y], bool p=nt(x);
	if (!ir(y)) ch[z][nt(y)]=x;
	fa[ch[x][!p]]=y; fa[y]=x; fa[x]=z;
	ch[y][p]=ch[x][!p]; ch[x][!p]=y;
	ud(y);
}
inline void splay(int x){
	static int sta[maxn],top;
	sta[top=1]=x;
	for(int y=x;!ir(y);y=fa[y]) sta[++top]=fa[y];
	while (top) pd(sta[top--]);
	while (!ir(x)){
		int y=fa[x];
		if (!ir(y)) rtt(nt(x)^nt(y)?x:y);
		rtt(x);
	}
	ud(x);
}
inline void access(int x){
	int t=0,y=x;
	while(x){
		splay(x); ch[x][1]=t;
		t=x; x=fa[x];
	}
	splay(y);
}

inline void link(int c, int f){ access(c); fa[c]=f; }
inline void cut(int x){ access(x); fa[ch[x][0]]=0; ch[x][0]=0; ud(x); }
inline void makeroot(int x){ access(x); rev[x]^=1; }

inline int find(int x){
	access(x);
	int y=x; while (ch[y][0]) y=ch[y][0];
	return y;
}
\end{lstlisting}

\subsection{LCT 不换根}
\begin{lstlisting}
//bzoj2002

#include<cstdio>

const int N=210000;

int fa[N],ch[N][2],size[N];

inline bool ir(int x){ return ch[fa[x]][0]!=x&&ch[fa[x]][1]!=x; }
inline bool nt(int x){ return ch[fa[x]][1]==x; }
inline void ud(int x){ size[x]=size[ch[x][0]]+size[ch[x][1]]+1; }

void rtt(int x){
	int y=fa[x], z=fa[y]; bool p=nt(x);
	if (!ir(y)) ch[z][nt(y)]=x;
	fa[y]=x; fa[x]=z; fa[ch[x][!p]]=y;
	ch[y][p]=ch[x][!p]; ch[x][!p]=y;
	ud(y);
}

void splay(int x){
	while (!ir(x)){
		int y=fa[x];
		if (!ir(y)) rtt(nt(x)^nt(y)?x:y);
		rtt(x);
	}
	ud(x);
}

void access(int x){
	int y=x, t=0;
	while (x){
		splay(x); ch[x][1]=t;
		t=x; x=fa[x];
	}
	splay(y);
}	
	
void link(int c, int f){ access(c); fa[c]=f; }
void cut(int x){ access(x); fa[ch[x][0]]=0; ch[x][0]=0; }

int main(){
	int n; scanf("%d",&n);
	for (int i=1;i<=n;i++) size[i]=1;
	for (int i=1;i<=n;i++){
		int k; scanf("%d",&k);
		if (i+k<=n) link(i,i+k);
	}
	int m; scanf("%d",&m);
	while (m--){
		int i,j,k; scanf("%d%d",&i,&j); j++;
		if (i==1){
			access(j);
			printf("%d\n",size[j]);
		}
		if (i==2){
			scanf("%d",&k);
			cut(j);
			if (j+k<=n) link(j,j+k);
		}
	}
	return 0;
}
\end{lstlisting}

\subsection{LCT 换根}
\begin{lstlisting}
//bzoj2049

#include<cstdlib>
#include<cstdio>
#define swap(a,b) {swp=a;a=b;b=swp;}
int swp;

inline void readint(int &x){
	x=0; char c=getchar();
	while (c<'0'||c>'9') c=getchar();
	while (c>='0'&&c<='9'){ x=x*10+c-'0'; c=getchar(); }
}

const int maxn=11000;

int n,m,fa[maxn],ch[maxn][2],sta[maxn],top;
bool rev[maxn];

inline bool ir(int x){ return ch[fa[x]][0]!=x && ch[fa[x]][1]!=x; }
inline bool nt(int x){ return ch[fa[x]][1]==x; }

inline void pd(int x){
	if (rev[x]){
		rev[ch[x][0]]^=1; rev[ch[x][1]]^=1;
		swap(ch[x][0],ch[x][1]); rev[x]=false;
	}
}

inline void rtt(int x){
	int y=fa[x], z=fa[y]; bool p=nt(x);
	if (!ir(y)) ch[z][nt(y)]=x;
	fa[ch[x][!p]]=y; fa[y]=x; fa[x]=z;
	ch[y][p]=ch[x][!p]; ch[x][!p]=y;
}

inline void splay(int x){
	top=0; sta[++top]=x;
	for (int y=x;!ir(y);y=fa[y]) sta[++top]=fa[y];
	while (top) pd(sta[top--]);
	while (!ir(x)){
		int y=fa[x];
		if (!ir(y)) rtt(nt(x)^nt(y)?x:y);
		rtt(x);
	}
}

inline void access(int x){
	int t=0;
	while (x){
		splay(x); ch[x][1]=t;
		t=x; x=fa[x];
	}
} 

inline void makeroot(int x){ access(x); splay(x); x[rev]^=1; }

inline void link(int x, int y){ makeroot(x); fa[x]=y; }

inline void cut(int x, int y){ makeroot(x); access(y); splay(y); ch[y][0]=fa[x]=0; }

inline int find(int x){
	access(x); splay(x);
	int y=x; while (ch[y][0]) y=ch[y][0];
	return y;
};	

int main(){
	readint(n); readint(m);
	while (m--){
		char s[10]; scanf("%s",s);
		int x,y; readint(x); readint(y);
		if (s[0]=='Q'){
			if (find(x)==find(y)) printf("Yes\n"); else printf("No\n");
		}
		if (s[0]=='C') link(x,y);
		if (s[0]=='D') cut(x,y);
	}
	return 0;
}
\end{lstlisting}

\subsection{左偏树}
\begin{lstlisting}
int a[N],lc[N],rc[N],d[N],size[N];

int merge(int x, int y){
	if (x==0) return y;
	if (y==0) return x;
	if (a[x]<a[y]){ int z=x; x=y; y=z; }
	rc[x]=merge(rc[x],y);
	if (d[rc[x]]>d[lc[x]]){ int t=lc[x]; lc[x]=rc[x]; rc[x]=t; }
	d[x]=d[rc[x]+1];
	size[x]=size[lc[x]]+size[rc[x]]+1;
	return x;
}

int pop(int x){
	return merge(lc[x],rc[x]);
}
\end{lstlisting}

\subsection{可持久化并查集}
\begin{lstlisting}
const int N=10000000;
int lc[N],rc[N],f[N],top;

int get(int x, int l, int r, int t){
	if (l==r) return f[x];
	int m=(l+r)>>1;
	if (t<=m) return get(lc[x],l,m,t);
	return get(rc[x],m+1,r,t);
}

int change(int x, int l, int r, int t, int d){
	if (l==r){
		f[++top]=d;
		return top;
	}
	int y=++top; lc[y]=lc[x]; rc[y]=rc[x];
	int m=(l+r)>>1;
	if (t<=m) lc[y]=change(lc[y],l,m,t,d);
		else rc[y]=change(rc[y],m+1,r,t,d);
	return y;
}

void build(int x, int l, int r){
	if (l==r){ f[x]=l; return; }
	int m=(l+r)>>1;
	build(lc[x]=++top,l,m);
	build(rc[x]=++top,m+1,r);
}
	
int a[200100],n,m;

int find(int i, int x){
	int fx=get(a[i],1,n,x);
	if (x==fx) return x;
	fx=find(i,fx);
	a[i]=change(a[i],1,n,x,fx);
	return fx;
}
\end{lstlisting}

\subsection{可持久化treap}
\begin{lstlisting}
#include<cstdlib>
#include<cstdio>
#define MIN(a,b) ((a)<(b)?(a):(b))
using namespace std;

struct treap{
	int data,fix;
	int size,add,min;
	bool flip;
	treap *l,*r;
	treap(int data):data(data), size(1), fix(rand()), l(NULL), r(NULL), add(0), min(data), flip(false){}
	
	void update(){
		size=(l?l->size:0)+(r?r->size:0)+1;
		min=data;
		if (l) min=MIN(min,l->min);
		if (r) min=MIN(min,r->min);
		min+=add;
	}
	
	void pushdown(){
		if (add){
			if (l) l->add+=add;
			if (r) r->add+=add;
			data+=add;
			add=0;
		}
		if (flip){
			flip=false;
			treap *t;
			t=l; l=r; r=t;
			if (l) l->flip=!l->flip;
			if (r) r->flip=!r->flip;
		}
		if (l) l->update();
		if (r) r->update();
	}
};

inline int size(treap *a){ return a?a->size:0; }

treap *merge(treap *a, treap *b){
	if (a==NULL) return b;
	if (b==NULL) return a;
	if (a->fix > b->fix){
		a->pushdown();
		a->r=merge(a->r,b);
		a->update();
		return a;
	} else {
		b->pushdown();
		b->l=merge(a,b->l);
		b->update();
		return b;
	}
}

void split(treap *x, int s, treap *&a, treap *&b){
	if (s<=0) { a=NULL; b=x; return; }
	if (s>=size(x)) { a=x; b=NULL; return; }
	x->pushdown();
	if (s<=size(x->l)) {
		split(x->l,s,a,b);
		x->l=b; b=x;
	} else {
		split(x->r,s-size(x->l)-1,a,b);
		x->r=a; a=x;
	}
	x->update();
	return;
}

void split3(treap *root, int x, int y, treap *&a, treap *&b, treap *&c){
	treap *t;
	split(root,x-1,a,t);
	split(t,y-x+1,b,c);
}

treap *merge3(treap *a, treap *b, treap *c){
	treap *t=merge(a,b);
	return merge(t,c);
}

treap *newnode(int data){
	treap *t=new treap(data);
	return t;
}

treap *root;

int main(){
	int n; scanf("%d",&n);
	for (int i=1;i<=n;i++){
		int data; scanf("%d",&data);
		root=merge(root,newnode(data));
	}
	
	int m; scanf("%d",&m);
	for (int i=1;i<=m;i++){
		int x,y,z;
		treap *a,*b,*c;
		char s[20]; scanf("%s",s);
		
		if (s[0]=='A'){
			scanf("%d%d%d",&x,&y,&z);
			split3(root,x,y,a,b,c);
			if (b) b->add+=z;
			b->update();
			root=merge3(a,b,c);
		}
		
		if (s[0]=='R' && s[3]=='E'){
			scanf("%d%d",&x,&y);
			split3(root,x,y,a,b,c);
			if (b) b->flip=!b->flip;
			root=merge3(a,b,c);
		}
		
		if (s[0]=='R' && s[3]=='O'){
			scanf("%d%d%d",&x,&y,&z);
			split3(root,x,y,a,b,c);
			if (b){
				z%=size(b);
				if (z<0) z+=size(b);
				treap *t1,*t2;
				split(b,size(b)-z,t1,t2);
				b=merge(t2,t1);
			}
			root=merge3(a,b,c);
		}
		
		if (s[0]=='I'){
			scanf("%d%d",&x,&y);
			split(root,x,a,b);
			root=merge(merge(a,newnode(y)),b);
		}
		
		if (s[0]=='D'){
			scanf("%d",&x);
			split3(root,x,x,a,b,c);
			if (b) delete b;
			root=merge(a,c);
		}
		
		if (s[0]=='M'){
			scanf("%d%d",&x,&y);
			split3(root,x,y,a,b,c);
			b->update();
			printf("%d\n",b->min);
			root=merge3(a,b,c);
		}
	}
	return 0;
}
\end{lstlisting}

\subsection{pq的妙用1}
\begin{lstlisting}
IL int gcd(int a, int b){
	while (b){ int c=a%b; a=b; b=c; }
	return a;
}

struct data { int a,b,x,y; };

IL bool OP< (const data &a, const data &b){
	return LL(a.x)*LL(b.y) > LL(a.y)*LL(b.x);
}

const int N=120000;
int n,L,d[N],v[N];

IL data get(int a, int b){
	int dd=d[a]-d[b];
	int vv=v[b]-v[a];
	if (vv<0) { vv=-vv; dd=-dd; }
	if (dd<0) dd+=L;
	return (data){a,b,dd,vv};
}

int l[N],r[N];
std::priority_queue<data> q;
bool ok[N];
int ansx,ansy;

struct co { int num,dis; } c[N];
IL bool comp(const co &a, const co &b) { return a.dis<b.dis; }

IL void solve(){
	scanf("%d%d",&n,&L);
	forto(i,1,n) scanf("%d",&d[i]);
	forto(i,1,n) scanf("%d",&v[i]);
	
	forto(i,1,n) c[i]=(co){i,d[i]};
	std::sort(c+1,c+n+1,comp);
	
	forto(i,2,n) l[c[i].num]=c[i-1].num;
	l[c[1].num]=c[n].num;
	
	forto(i,1,n-1) r[c[i].num]=c[i+1].num;
	r[c[n].num]=c[1].num;
	
	forto(i,1,n) ok[i]=true;
	
	while (!q.empty()) q.pop();
	forto(i,1,n) q.push(get(i,r[i]));
	
	forto(ttt,2,n){
		data da=q.top(); q.pop();
		
		while (!ok[da.a]||!ok[da.b]) {
			da=q.top(); q.pop();
		}
		
		int a=da.a, b=da.b;
		ansx=da.x, ansy=da.y;
		
		if (r[b]==a) std::swap(a,b);
		if (a>b){
			ok[b]=false;
			r[a]=r[b];
			l[r[a]]=a;
			q.push(get(a,r[a]));
		} else {
			ok[a]=false;
			l[b]=l[a];
			r[l[b]]=b;
			q.push(get(b,l[b]));
		}
	}
	
	int g=gcd(ansx,ansy);
	ansx/=g; ansy/=g;
	if (ansx) printf("%d/%d\n",ansx,ansy); else printf("0\n");
}

int main(){
	int test; scanf("%d",&test);
	while (test--) solve();
}
\end{lstlisting}

\subsection{pq的妙用2}
\begin{lstlisting}
#include <bits/stdc++.h>
#define forto(i,a,b) for(int i=(a);i<=(b);i++)
typedef double D;
const D eps=1e-8;

const int N=200200;

struct data { D x; int k; D t; } a[N];

inline bool comp1(const data &a, const data &b){
	return a.x<b.x;
}

struct meet { int xx,yy; D t,x; };

inline bool operator< (const meet &a, const meet &b){
	return a.t>b.t;
}

bool get(data a, data b, D &t, D &x){
	if (a.t>b.t) std::swap(a,b);
	D va=100.0/a.k;
	D vb=100.0/b.k;
	a.x+=va*(b.t-a.t);
	a.t=b.t;
	if (a.x>b.x) { std::swap(a,b); std::swap(va,vb); }
	if (b.x-a.x<=eps){
		x=a.x;
		t=a.t;
		return true;
	}	
	if (a.k>=b.k) return false;
	t=(b.x-a.x)/(va-vb);
	x=a.x+t*va;
	t+=a.t;
	return true;
}

int l[N],r[N];
std::priority_queue<meet> q;

bool b[N];

int main(){
	int n; scanf("%d",&n);
	forto(i,1,n) scanf("%d%lf",&a[i].k,&a[i].x);
	std::sort(a+1,a+n+1,comp1);
	forto(i,2,n) l[i]=i-1;
	forto(i,2,n) r[i-1]=i;
	
	forto(i,2,n){
		D t,x;
		if (get(a[i-1],a[i],t,x)) q.push((meet){i-1,i,t,x});
	}
	
	while (!q.empty()){
		meet m=q.top(); q.pop();
		while (!q.empty() && (b[m.xx]||b[m.yy])) { m=q.top(); q.pop(); }
		if (b[m.xx]||b[m.yy]) break;
		
		int p1=m.xx, p2=m.yy;
		
		n++;
		a[n].x=m.x;
		a[n].k=a[p1].k+a[p2].k;
		a[n].t=m.t;
		
		if (r[p2]==p1) std::swap(p1,p2);
		l[n]=l[p1];
		r[l[n]]=n;
		
		r[n]=r[p2];
		l[r[n]]=n;
		
		b[p1]=b[p2]=true;
		
		D t,x;
		if (l[n] && get(a[n],a[l[n]],t,x)) q.push((meet){n,l[n],t,x});
		if (r[n] && get(a[n],a[r[n]],t,x)) q.push((meet){n,r[n],t,x});
	}
	
	int ans=0;
	forto(i,1,n) if (!b[i]) ans++;
	printf("%d\n",ans);
	forto(i,1,n) if (!b[i]) printf("%d ",a[i].k);
	return 0;
}
\end{lstlisting}

\subsection{线段树(camp)}
\begin{lstlisting}
#include <bits/stdc++.h>
#define forto(i,a,b) for(int i=(a);i<=(b);i++)
using namespace std;
typedef long long LL;
const int N=600000;
const LL inf=N*1000;

struct flag{
	LL a,b,c;
	flag(LL a=0, LL b=1, LL c=0):a(a),b(b),c(c){}
	void operator+= (const flag &f){
		a+=b*(c+f.a); b*=f.b; c=f.c; c+=a/b; a%=b;
		if (b>=inf){
			a-=(b-inf); b-=(b-inf); if (a<0) a=0;
		}
	}
};
struct data{
	LL mx;
	data(int mx=0):mx(mx){}

	void operator+= (const flag &f){
		mx=(mx+f.a)/f.b+f.c;
	}
};
data operator+ (const data &x, const data &y){
	return data(max(x.mx,y.mx));
}

struct seg_tree{
	int n; flag f[N]; data d[N];
	
	void update(int x, int l, int r){
		if (l==r){
			d[x]+=f[x];
			f[x]=flag();
			return;
		}
		d[x]=d[x<<1]+d[x<<1|1];
		d[x]+=f[x];
	}
	void pushdown(int x, int l, int r){
		f[x<<1]+=f[x];
		f[x<<1|1]+=f[x];
		f[x]=flag();
		int m=(l+r)>>1;
		update(x<<1,l,m);
		update(x<<1|1,m+1,r);
	}
	
	int ll,rr; flag t; data q;
	
	void modify2(int x, int l, int r){
		if (ll<=l && r<=rr){
			f[x]+=t;
			update(x,l,r);
			return;
		}
		pushdown(x,l,r);
		int m=(l+r)>>1;
		if (ll<=m) modify2(x<<1,l,m);
		if (rr>m) modify2(x<<1|1,m+1,r);
		update(x,l,r);
	}
	void modify(int l, int r, flag f){
		ll=l; rr=r; t=f;
		modify2(1,1,n);
	}
	
	void query2(int x, int l, int r){
		if (ll<=l && r<=rr){
			q=q+d[x];
			return;
		}
		pushdown(x,l,r);
		int m=(l+r)>>1;
		if (ll<=m) query2(x<<1,l,m);
		if (rr>m) query2(x<<1|1,m+1,r);
	}
	data query(int l, int r){
		ll=l; rr=r; q=data();
		query2(1,1,n);
		return q;
	}
} tr;

int main(){
	int n,m; scanf("%d%d",&n,&m);
	tr.n=n;
	forto(i,1,n){
		int x; scanf("%d",&x);
		tr.modify(i,i,flag(x));
	}
	
	while (m--){
		int t,l,r,x; scanf("%d%d%d%d",&t,&l,&r,&x);
		l++; r++;
		if (t==0) tr.modify(l,r,flag(x));
		if (t==1) tr.modify(l,r,flag(0,x));
		if (t==2) printf("%lld\n",tr.query(l,r).mx);
	}
	return 0;
}

// 另一种写法
void pushdown(int x, int l, int r){
	d[x]+=f[x];
	if (l<r){
		f[x<<1]+=f[x];
		f[x<<1|1]+=f[x];
	}
	f[x]=flag();
}

void update(int x, int l, int r){
	int m=(l+r)>>1;
	pushdown(x<<1,l,m);
	pushdown(x<<1|1,m+1,r);
	d[x]=d[x<<1]+d[x<<1|1];
}

void modify2(int x, int l, int r){
	if (ll<=l && r<=rr) { f[x]+=t; return; }
	pushdown(x,l,r);
	int m=(l+r)>>1;
	if (ll<=m) modify2(x<<1,l,m);
	if (rr>m) modify2(x<<1|1,m+1,r);
	update(x,l,r);
}

void query2(int x, int l, int r){
	pushdown(x,l,r);
	if (ll<=l && r<=rr) { q=q+d[x]; return; }
	int m=(l+r)>>1;
	if (ll<=m) query2(x<<1,l,m);
	if (rr>m) query2(x<<1|1,m+1,r);
}
\end{lstlisting}

\section{其他内容}

\subsection{决策单调性}
\begin{lstlisting}
#include <bits/stdc++.h>
#define forto(i,a,b) for(int i=(a);i<=(b);i++)
using namespace std;
typedef long long LL;

const int N=2050;

int n,g,k;
LL a[N],s1[N],s2[N];

LL get(int l, int r){
	if (k==1){
		int m=(l+r)>>1;
		LL t1 = a[m]*(m-l) - (s1[m-1]-s1[l-1]);
		LL t2 = (s1[r]-s1[m]) - a[m]*(r-m);
		return t1+t2;
	}
	LL n = r-l+1;
	LL sum1 = s1[r]-s1[l-1];
	LL sum2 = s2[r]-s2[l-1];
	
	LL v = sum1/n;
	LL t1 = n*v*v - 2*sum1*v + sum2;
	v++;
	LL t2 = n*v*v - 2*sum1*v + sum2;
	return min(t1,t2);
}

LL c[N][N],f[N][N];
LL pre[N][N];

void dfs(int t, int l, int r, int mn, int mx){
	int i=(l+r)>>1;
	int p1=max(mn,t-1);
	int p2=min(mx,i-1);
	
	int mj=p1;
	LL ans=f[t-1][mj]+c[mj+1][i];
		
	forto(j,p1+1,p2){
		LL d=f[t-1][j]+c[j+1][i];
		if (d<=ans){
			ans=d;
			mj=j;
		}
	}
	pre[t][i]=mj;
	f[t][i]=ans;
	if (l<i) dfs(t,l,i-1,mn,min(mx,mj));
	if (i<r) dfs(t,i+1,r,max(mn,mj),mx);
}

int main(){
	scanf("%d%d%d",&n,&g,&k);
	forto(i,1,n) scanf("%lld",&a[i]);
	forto(i,1,n) s1[i]=s1[i-1]+a[i];
	forto(i,1,n) s2[i]=s2[i-1]+a[i]*a[i];
	forto(l,1,n) forto(r,l,n) c[l][r]=get(l,r);
	
	forto(i,1,n) f[1][i]=c[1][i];
	forto(t,2,g) dfs(t,t,n,t-1,n-1);
	
	printf("%lld\n",f[g][n]);
	return 0;
}
\end{lstlisting}

\subsection{十字链表}
\begin{lstlisting}
#include <bits/stdc++.h>
#define forto(i,a,b) for(int i=(a);i<=(b);i++)
#define fordown(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;

const int N=1050;

char s[N][N];
int a[N*N][4];

int get(int x, int y, int z){
	int i=0;
	while (a[y][i]!=x) i++;
	return a[y][(i+z)%4];
}

void move(int &x, int &y, int z){
	z=get(x,y,z);
	x=y; y=z;
}

void change(int x1, int y1, int y2){
	int i=0;
	while (a[x1][i]!=y1) i++;
	a[x1][i]=y2;
}

int in[4][N],out[4][N];
int ans[N][N];

int main(){
	int n,q; scanf("%d%d",&n,&q);
	forto(i,1,n) scanf("%s",s[i]+1);
	n+=2;
	forto(i,1,n*n){
		if (i>n) a[i][0]=i-n;
		if (i%n) a[i][1]=i+1;
		if (i+n<=n*n) a[i][2]=i+n;
		if (i%n!=1) a[i][3]=i-1;
	}
	while (q--){
		int I,J,S; scanf("%d%d%d",&I,&J,&S);
		int x=1, y=2;
		forto(i,2,J) move(x,y,2);
		move(x,y,3);
		forto(i,2,I) move(x,y,2);
		
		forto(k,0,3){
			in[k][1]=y;
			out[k][1]=get(x,y,3);
			forto(i,2,S){
				move(x,y,2);
				in[k][i]=y;
				out[k][i]=get(x,y,3);
			}
			move(x,y,3);
			swap(x,y);
		}
		forto(i,0,3) forto(j,1,S){
			change(in[i][j],out[i][j],out[(i+1)&3][j]);
			change(out[i][j],in[i][j],in[(i+3)&3][j]);
		}
	}
	
	n-=2;
	forto(j,1,n){
		int x=1, y=2;
		forto(jj,2,j) move(x,y,2);
		move(x,y,3);
		ans[1][j]=y;
		forto(i,2,n){
			move(x,y,2);
			ans[i][j]=y;
		}
	}
	
	forto(i,1,n) forto(j,1,n){
		int t=ans[i][j]-1;
		putchar(s[t/(n+2)][t%(n+2)]);
		if (j==n) putchar('\n');
	}
	return 0;
}
\end{lstlisting}

\subsection{高精度}
\begin{lstlisting}
//源码以GPLv3协议发布
//欢迎大家寻找bug、修复bug、增加功能、提出意见等 
//各位同学捉到虫子请交萌萌哒HZ处理!（2333）
//		——萌萌哒HZ，2016年2月14日 21:03

#include<cstdlib>
#include<cstdio>
#include<cstring>

#define forto(i,a,b) for(int i=(a);i<=(b);i++)
#define fordown(i,a,b) for(int i=(a);i>=(b);i--)

#define MIN(a,b) ((a)<(b)?(a):(b))
#define MAX(a,b) ((a)>(b)?(a):(b))

#define maxlen 2500
#define MOD 10000

inline void thr(const char s[]){
	printf("\n呜呜呜……程序出错啦……内容为：\n\n%s\n\n有问题，就找萌萌哒HZ\n\n",s);
	system("pause");
	exit(0);
}

struct bigint{
	int len;
	int x[maxlen+2];
	
	bigint(int a){
		memset(x,0,sizeof(x));
		len=0;
		while (a){
			x[++len]=a%MOD;
			a/=MOD;
		}
	}
	
	inline void operator+= (const bigint &a){
		forto(i,1,a.len) x[i]+=a.x[i];
		if (a.len>len) len=a.len;
		forto(i,1,len) if (x[i]>=MOD){
			x[i]-=MOD;
			x[i+1]+=1;
		}
		if (x[len+1]) len++;
		if (len>maxlen) thr("加法溢出");
	}
	
	inline void operator-= (const bigint &a){
		forto(i,1,a.len) x[i]-=a.x[i];
		forto(i,1,len) if (x[i]<0){
			x[i]+=MOD;
			x[i+1]-=1;
		}
		while (len && !x[len]) len--;
	}
	
	inline void up(){
		forto(i,1,len){
			x[i+1]+=x[i]/MOD;
			x[i]%=MOD;
		}
		if (x[len+1]) len++;
		if (len>maxlen) thr("乘法溢出");
	}
	
//	inline void operator*= (int a){
//		forto(i,1,len) x[i]*=a;
//		up();
//	}
//	
//	inline void operator/= (int a){
//		if (a==0) thr("除数为零");
//		fordown(i,len,2){
//			x[i-1]+=x[i]%a*MOD;
//			x[i]/=a;
//		}
//		x[1]/=a;
//		while (len && !x[len]) len--;
//	}
//	
//	inline int operator% (int a) const{
//		if (a==0) thr("除数为零");
//		int ans=0;
//		fordown(i,len,1){
//			ans=ans*MOD+x[i];
//			ans%=a;
//		}
//		return ans;
//	}
	
	inline void c2(){
		forto(i,1,len) x[i]<<=1;
		forto(i,1,len) if (x[i]>=MOD){
			x[i]-=MOD;
			x[i+1]+=1;
		}
		if (x[len+1]) len++;
		if (len>maxlen) thr("内部运算溢出");
	}
	
	inline void div2(){
		fordown(i,len,2){
			if (x[i]&1) x[i-1]+=MOD;
			x[i]>>=1;
		}
		x[1]>>=1;
		if (len && !x[len]) len--;
	}
	
	inline void print() const{
		printf("%d",x[len]);
		fordown(i,len-1,1) printf("%04d",x[i]);
	}
};

inline int comp(const bigint &a, const bigint &b){
	if (a.len>b.len) return 1;
	if (a.len<b.len) return -1;
	fordown(i,a.len,1){
		if (a.x[i]>b.x[i]) return 1;
		if (a.x[i]<b.x[i]) return -1;
	}
	return 0;
}

inline bool operator== (const bigint &a, const bigint &b){ return comp(a,b)==0; }
inline bool operator!= (const bigint &a, const bigint &b){ return comp(a,b)!=0; }
inline bool operator>  (const bigint &a, const bigint &b){ return comp(a,b)> 0; }
inline bool operator>= (const bigint &a, const bigint &b){ return comp(a,b)>=0; }
inline bool operator<  (const bigint &a, const bigint &b){ return comp(a,b)< 0; }
inline bool operator<= (const bigint &a, const bigint &b){ return comp(a,b)<=0; }

inline bigint operator+ (bigint a, const bigint &b){ a+=b; return a; }
inline bigint operator- (bigint a, const bigint &b){ a-=b; return a; }
//inline bigint operator* (bigint a, int b){ a*=b; return a; }
//inline bigint operator/ (bigint a, int b){ a/=b; return a; }

inline bigint operator* (const bigint &a, const bigint &b){
	if (a.len==0||b.len==0) return bigint(0);
	if (a.len+b.len-1>maxlen) thr("乘法溢出");
	bigint c(0);
	forto(i,1,a.len)
	forto(j,1,b.len)
		c.x[i+j-1]+=a.x[i]*b.x[j];
	c.len=a.len+b.len-1;
	c.up();
	return c;
}

inline bigint operator/ (bigint a, bigint b){
	if (b.len==0) thr("除数为零");
	bigint ans(0),k(1);
	while (b<a){
		k.c2();
		b.c2();
	}
	while (k.len){
		if (a>=b){
			a-=b;
			ans+=k;
		}
		k.div2();
		b.div2();
	}
	return ans;
}

inline bigint operator% (bigint a, bigint b){
	if (b.len==0) thr("除数为零");
	int i=1;
	while (b<a){ b.c2(); i++; }
	while (i--){
		if (a>=b) a-=b;
		b.div2();
	}
	return a;
}

inline void operator*= (bigint &a, const bigint &b){ a=a*b; }
inline void operator/= (bigint &a, bigint b){ a=a/b; }
inline void operator%= (bigint &a, bigint b){ a=a%b; }

inline bigint gcd(bigint a, bigint b){
	while (a.len && b.len) if (a>=b) a%=b; else b%=a;
	return a.len?a:b;
}	

struct number{
	bigint x,y;
	bool s;
	number():x(0),y(1),s(false){}
	number(int x, int y=1, bool s=false):x(x),y(y),s(s){}
	number(const bigint &x, const bigint &y=bigint(1), bool s=false):x(x),y(y),s(s){}
	
	inline void simp(){
		bigint d=gcd(x,y);
		x/=d; y/=d;
		if (x==0) s=false;
		if (y==0) thr("分母为零");
	}
	
	inline void print1() const{
		if (s) printf("-");
		x.print();
		if (y!=bigint(1)){
			printf(" / ");
			y.print();
		}
	}
	
	inline void print2() const;
	inline void print3() const;
	
	inline void print() const{
		print1();
		printf("\n");
		if (y!=bigint(1)){
			printf("          or\n          ");
			print2();
			printf("\n");
		}
		printf("          or\n          ");
		print3();
		printf("\n");
	}	
};

inline int comp(const number &a, const number &b){
	if (!a.s && b.s) return 1;
	if (a.s && !b.s) return -1;
	return comp(a.x*b.y, b.x*a.y);
}

inline bool operator== (const number &a, const number &b){ return comp(a,b)==0; }
inline bool operator!= (const number &a, const number &b){ return comp(a,b)!=0; }
inline bool operator>  (const number &a, const number &b){ return comp(a,b)> 0; }
inline bool operator>= (const number &a, const number &b){ return comp(a,b)>=0; }
inline bool operator<  (const number &a, const number &b){ return comp(a,b)< 0; }
inline bool operator<= (const number &a, const number &b){ return comp(a,b)<=0; }

inline number operator* (const number &a, const number &b){
	number c(a.x*b.x, a.y*b.y, a.s^b.s);
	c.simp();
	return c;
}

inline number operator/ (const number &a, const number &b){
	number c(a.x*b.y, a.y*b.x, a.s^b.s);
	c.simp();
	return c;
}

inline number operator+ (const number &a, const number &b){
	number c; 
	if (a.s==b.s) c=number(a.x*b.y+b.x*a.y, a.y*b.y, a.s);
	else if (a.x*b.y > b.x*a.y) c=number(a.x*b.y - b.x*a.y, a.y*b.y, a.s);
	else c=number(b.x*a.y - a.x*b.y, a.y*b.y, b.s);
	c.simp();
	return c;
}

inline number operator- (const number &a, const number &b){
	return a+b*number(1,1,true);
}

inline void operator+= (number &a, const number &b){ a=a+b; }
inline void operator-= (number &a, const number &b){ a=a-b; }
inline void operator*= (number &a, const number &b){ a=a*b; }
inline void operator/= (number &a, const number &b){ a=a/b; }

inline void number::print2() const{
	if (s) printf("-");
	bigint z=x/y;
	z.print();
	printf(".");
	number a=(*this)-number(z);
	number k(1);
	forto(i,1,5){
		k=k/number(10);
		int t=0;
		while (a>=k){
			a=a-k;
			t++;
		}
		printf("%d",t);
	}
	k=k/number(10);
	int t=0;
	while (a>=k){
		a=a-k;
		t++;
	}
	if (a>=k/number(2)) t++;
	printf("%d",t);
}

inline void number::print3() const{
	number t=*this;
	if (t.s){
		printf("-");
		t.s=false;
	}
	int k=0;
	while (t>=number(10)){
		t/=number(10);
		k++;
	}
	while (t<number(1)){
		t*=number(10);
		k--;
	}
	t.print2();
	printf("*10^%d",k);
}	

inline number pow(number a, int n){
	static bool s[30];
	static int t;
	static number p;
	
	for (t=0;n;n>>=1) s[++t]=n&1;
	for (p=number(1);t;t--){
		p=p*p;
		if (s[t]) p=p*a;
	}
	return p;
}

inline int pri(char a){
	if (a=='(') return 0;
	if (a=='c') return 1;
	if (a=='+'||a=='-') return 2;
	if (a=='*'||a=='/'||a=='%') return 3;
	if (a=='^') return 4;
	return 0;
}

inline number __ope(const number &a, const number &b, char s){
	if (s=='+') return a+b;
	if (s=='-') return a-b;
	if (s=='*') return a*b;
	if (s=='/') return a/b;
	if (s=='%'){
		if (a.y!=bigint(1)||b.y!=bigint(1)) thr("暂不支持分数取模");
		if (a.s||b.s) thr("暂不支持负数取模");
		return number(a.x%b.x);
	}	
	if (s=='^'){
		if (b.y!=bigint(1)) thr("指数暂时不能为分数");
		if (b.s) thr("指数暂时不能为负数");
		if (b.x.len>1) thr("为避免乘法溢出，已限制指数必须小于10000");
		return pow(a, b.x.x[1]);
	}
	if (s=='c') return number(comp(a,b));
	return number(0);
} 

#define maxstrlen 10001 
#define maxstalen 101 

char s[maxstrlen];
number num[maxstalen];
char sym[maxstalen];
int topnum, topsym;

inline void ope(){
	num[topnum-1]=__ope(num[topnum-1],num[topnum],sym[topsym]);
	topnum--; topsym--;
}

number save[101];

inline void read_and_calc(int t){
	gets(s);
	topnum=0, topsym=0;
	num[1]=number(0);
	bool b=false;
	
	for(int i=0;s[i];){
		if ( (s[i]>='0'&&s[i]<='9') || ( (s[i]=='-'||s[i]=='+') && !b) || s[i]=='#' ){
			if (b==true) thr("多余的数字（缺少运算符）");
			if (s[i]=='+') i++; else
			if (s[i]=='-'){
				num[++topnum]=number(1,1,true);
				sym[++topsym]='*';
				i++;
			} else 
			if (s[i]=='#'){
				b=true;
				i++;
				if (s[i]<'0'||s[i]>'9') thr("#号之后应有数字");
				int k=0;
				while (s[i]>='0' && s[i]<='9'){
					k=k*10+(s[i]-'0');
					i++;
				}
				if (k==0||k>=t) thr("引用了未使用的结果");
				num[++topnum]=save[k];
			} else {
				b=true;
				number t;
				while (s[i]>='0' && s[i]<='9'){
					t=t*number(10)+number(s[i]-'0');
					i++;
				}
				if (s[i]=='.'){
					i++;
					number k(1);
					while (s[i]>='0' && s[i]<='9'){
						k/=10;
						t+=(s[i]-'0')*k;
						i++;
					}
				}
				num[++topnum]=t;
			}
		} else
		
		if (s[i]=='('){
			if (b==true) thr("左括号前缺少运算符"); 
			sym[++topsym]='(';
			i++;
		} else
		
		if (s[i]==')'){
			if (b==false) thr("右括号前缺少数字"); 
			while (topsym && sym[topsym]!='(') ope();
			if (topsym==0) thr("括号不匹配");
			topsym--;
			i++;
		} else
		
		if(s[i]=='+'||s[i]=='-'||s[i]=='*'||s[i]=='/'||s[i]=='^'||s[i]=='%'||s[i]=='c'){
			if (b==false) thr("多余的运算符（缺少数字）");
			b=false;
			
			while (pri(s[i])<=pri(sym[topsym])) ope();
			sym[++topsym]=s[i];
			i++;
		} else
		
		if (s[i]==' ') i++; else thr("输入中含有多余内容"); 
	}
	while (topsym && sym[topsym]!='(') ope();
	if (topsym) thr("括号不匹配"); 
	printf("Out [%02d]: ",t);
	num[1].print();
	printf("\n");
	save[t]=num[1];
}

int main(){
	forto(t,1,99){
		printf("In  [%02d]: ",t);
		read_and_calc(t);
	}
	return 0;
}
\end{lstlisting}
\end{document}